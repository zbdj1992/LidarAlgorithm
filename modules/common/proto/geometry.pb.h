// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: geometry.proto

#ifndef PROTOBUF_INCLUDED_geometry_2eproto
#define PROTOBUF_INCLUDED_geometry_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_geometry_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_geometry_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[18]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_geometry_2eproto();
namespace lidar_algorithm {
namespace common {
namespace proto {
class AABB3D;
class AABB3DDefaultTypeInternal;
extern AABB3DDefaultTypeInternal _AABB3D_default_instance_;
class AABB3Ds;
class AABB3DsDefaultTypeInternal;
extern AABB3DsDefaultTypeInternal _AABB3Ds_default_instance_;
class Box2D;
class Box2DDefaultTypeInternal;
extern Box2DDefaultTypeInternal _Box2D_default_instance_;
class Box3D;
class Box3DDefaultTypeInternal;
extern Box3DDefaultTypeInternal _Box3D_default_instance_;
class Cluster;
class ClusterDefaultTypeInternal;
extern ClusterDefaultTypeInternal _Cluster_default_instance_;
class Clusters;
class ClustersDefaultTypeInternal;
extern ClustersDefaultTypeInternal _Clusters_default_instance_;
class OBB3D;
class OBB3DDefaultTypeInternal;
extern OBB3DDefaultTypeInternal _OBB3D_default_instance_;
class OBB3Ds;
class OBB3DsDefaultTypeInternal;
extern OBB3DsDefaultTypeInternal _OBB3Ds_default_instance_;
class ObsOccuPathPct;
class ObsOccuPathPctDefaultTypeInternal;
extern ObsOccuPathPctDefaultTypeInternal _ObsOccuPathPct_default_instance_;
class PathLines;
class PathLinesDefaultTypeInternal;
extern PathLinesDefaultTypeInternal _PathLines_default_instance_;
class Point2D;
class Point2DDefaultTypeInternal;
extern Point2DDefaultTypeInternal _Point2D_default_instance_;
class Point3D;
class Point3DDefaultTypeInternal;
extern Point3DDefaultTypeInternal _Point3D_default_instance_;
class PointCloud;
class PointCloudDefaultTypeInternal;
extern PointCloudDefaultTypeInternal _PointCloud_default_instance_;
class PointPair;
class PointPairDefaultTypeInternal;
extern PointPairDefaultTypeInternal _PointPair_default_instance_;
class PointTriple;
class PointTripleDefaultTypeInternal;
extern PointTripleDefaultTypeInternal _PointTriple_default_instance_;
class PointXYZIL;
class PointXYZILDefaultTypeInternal;
extern PointXYZILDefaultTypeInternal _PointXYZIL_default_instance_;
class Polygon;
class PolygonDefaultTypeInternal;
extern PolygonDefaultTypeInternal _Polygon_default_instance_;
class Quaternion;
class QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
}  // namespace proto
}  // namespace common
}  // namespace lidar_algorithm
namespace google {
namespace protobuf {
template<> ::lidar_algorithm::common::proto::AABB3D* Arena::CreateMaybeMessage<::lidar_algorithm::common::proto::AABB3D>(Arena*);
template<> ::lidar_algorithm::common::proto::AABB3Ds* Arena::CreateMaybeMessage<::lidar_algorithm::common::proto::AABB3Ds>(Arena*);
template<> ::lidar_algorithm::common::proto::Box2D* Arena::CreateMaybeMessage<::lidar_algorithm::common::proto::Box2D>(Arena*);
template<> ::lidar_algorithm::common::proto::Box3D* Arena::CreateMaybeMessage<::lidar_algorithm::common::proto::Box3D>(Arena*);
template<> ::lidar_algorithm::common::proto::Cluster* Arena::CreateMaybeMessage<::lidar_algorithm::common::proto::Cluster>(Arena*);
template<> ::lidar_algorithm::common::proto::Clusters* Arena::CreateMaybeMessage<::lidar_algorithm::common::proto::Clusters>(Arena*);
template<> ::lidar_algorithm::common::proto::OBB3D* Arena::CreateMaybeMessage<::lidar_algorithm::common::proto::OBB3D>(Arena*);
template<> ::lidar_algorithm::common::proto::OBB3Ds* Arena::CreateMaybeMessage<::lidar_algorithm::common::proto::OBB3Ds>(Arena*);
template<> ::lidar_algorithm::common::proto::ObsOccuPathPct* Arena::CreateMaybeMessage<::lidar_algorithm::common::proto::ObsOccuPathPct>(Arena*);
template<> ::lidar_algorithm::common::proto::PathLines* Arena::CreateMaybeMessage<::lidar_algorithm::common::proto::PathLines>(Arena*);
template<> ::lidar_algorithm::common::proto::Point2D* Arena::CreateMaybeMessage<::lidar_algorithm::common::proto::Point2D>(Arena*);
template<> ::lidar_algorithm::common::proto::Point3D* Arena::CreateMaybeMessage<::lidar_algorithm::common::proto::Point3D>(Arena*);
template<> ::lidar_algorithm::common::proto::PointCloud* Arena::CreateMaybeMessage<::lidar_algorithm::common::proto::PointCloud>(Arena*);
template<> ::lidar_algorithm::common::proto::PointPair* Arena::CreateMaybeMessage<::lidar_algorithm::common::proto::PointPair>(Arena*);
template<> ::lidar_algorithm::common::proto::PointTriple* Arena::CreateMaybeMessage<::lidar_algorithm::common::proto::PointTriple>(Arena*);
template<> ::lidar_algorithm::common::proto::PointXYZIL* Arena::CreateMaybeMessage<::lidar_algorithm::common::proto::PointXYZIL>(Arena*);
template<> ::lidar_algorithm::common::proto::Polygon* Arena::CreateMaybeMessage<::lidar_algorithm::common::proto::Polygon>(Arena*);
template<> ::lidar_algorithm::common::proto::Quaternion* Arena::CreateMaybeMessage<::lidar_algorithm::common::proto::Quaternion>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace lidar_algorithm {
namespace common {
namespace proto {

// ===================================================================

class Point2D :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lidar_algorithm.common.proto.Point2D) */ {
 public:
  Point2D();
  virtual ~Point2D();

  Point2D(const Point2D& from);

  inline Point2D& operator=(const Point2D& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Point2D(Point2D&& from) noexcept
    : Point2D() {
    *this = ::std::move(from);
  }

  inline Point2D& operator=(Point2D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Point2D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point2D* internal_default_instance() {
    return reinterpret_cast<const Point2D*>(
               &_Point2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Point2D* other);
  friend void swap(Point2D& a, Point2D& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Point2D* New() const final {
    return CreateMaybeMessage<Point2D>(nullptr);
  }

  Point2D* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Point2D>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Point2D& from);
  void MergeFrom(const Point2D& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point2D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // double y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // @@protoc_insertion_point(class_scope:lidar_algorithm.common.proto.Point2D)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double x_;
  double y_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class Point3D :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lidar_algorithm.common.proto.Point3D) */ {
 public:
  Point3D();
  virtual ~Point3D();

  Point3D(const Point3D& from);

  inline Point3D& operator=(const Point3D& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Point3D(Point3D&& from) noexcept
    : Point3D() {
    *this = ::std::move(from);
  }

  inline Point3D& operator=(Point3D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Point3D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point3D* internal_default_instance() {
    return reinterpret_cast<const Point3D*>(
               &_Point3D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Point3D* other);
  friend void swap(Point3D& a, Point3D& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Point3D* New() const final {
    return CreateMaybeMessage<Point3D>(nullptr);
  }

  Point3D* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Point3D>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Point3D& from);
  void MergeFrom(const Point3D& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point3D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // double y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // double z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:lidar_algorithm.common.proto.Point3D)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double x_;
  double y_;
  double z_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class Polygon :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lidar_algorithm.common.proto.Polygon) */ {
 public:
  Polygon();
  virtual ~Polygon();

  Polygon(const Polygon& from);

  inline Polygon& operator=(const Polygon& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Polygon(Polygon&& from) noexcept
    : Polygon() {
    *this = ::std::move(from);
  }

  inline Polygon& operator=(Polygon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Polygon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Polygon* internal_default_instance() {
    return reinterpret_cast<const Polygon*>(
               &_Polygon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Polygon* other);
  friend void swap(Polygon& a, Polygon& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Polygon* New() const final {
    return CreateMaybeMessage<Polygon>(nullptr);
  }

  Polygon* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Polygon>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Polygon& from);
  void MergeFrom(const Polygon& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Polygon* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .lidar_algorithm.common.proto.Point3D points = 1;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 1;
  ::lidar_algorithm::common::proto::Point3D* mutable_points(int index);
  ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point3D >*
      mutable_points();
  const ::lidar_algorithm::common::proto::Point3D& points(int index) const;
  ::lidar_algorithm::common::proto::Point3D* add_points();
  const ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point3D >&
      points() const;

  // @@protoc_insertion_point(class_scope:lidar_algorithm.common.proto.Polygon)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point3D > points_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class PointPair :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lidar_algorithm.common.proto.PointPair) */ {
 public:
  PointPair();
  virtual ~PointPair();

  PointPair(const PointPair& from);

  inline PointPair& operator=(const PointPair& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PointPair(PointPair&& from) noexcept
    : PointPair() {
    *this = ::std::move(from);
  }

  inline PointPair& operator=(PointPair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PointPair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PointPair* internal_default_instance() {
    return reinterpret_cast<const PointPair*>(
               &_PointPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(PointPair* other);
  friend void swap(PointPair& a, PointPair& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PointPair* New() const final {
    return CreateMaybeMessage<PointPair>(nullptr);
  }

  PointPair* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PointPair>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PointPair& from);
  void MergeFrom(const PointPair& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointPair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .lidar_algorithm.common.proto.Point2D left = 1;
  bool has_left() const;
  void clear_left();
  static const int kLeftFieldNumber = 1;
  const ::lidar_algorithm::common::proto::Point2D& left() const;
  ::lidar_algorithm::common::proto::Point2D* release_left();
  ::lidar_algorithm::common::proto::Point2D* mutable_left();
  void set_allocated_left(::lidar_algorithm::common::proto::Point2D* left);

  // .lidar_algorithm.common.proto.Point2D right = 2;
  bool has_right() const;
  void clear_right();
  static const int kRightFieldNumber = 2;
  const ::lidar_algorithm::common::proto::Point2D& right() const;
  ::lidar_algorithm::common::proto::Point2D* release_right();
  ::lidar_algorithm::common::proto::Point2D* mutable_right();
  void set_allocated_right(::lidar_algorithm::common::proto::Point2D* right);

  // @@protoc_insertion_point(class_scope:lidar_algorithm.common.proto.PointPair)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::lidar_algorithm::common::proto::Point2D* left_;
  ::lidar_algorithm::common::proto::Point2D* right_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class PointTriple :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lidar_algorithm.common.proto.PointTriple) */ {
 public:
  PointTriple();
  virtual ~PointTriple();

  PointTriple(const PointTriple& from);

  inline PointTriple& operator=(const PointTriple& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PointTriple(PointTriple&& from) noexcept
    : PointTriple() {
    *this = ::std::move(from);
  }

  inline PointTriple& operator=(PointTriple&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PointTriple& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PointTriple* internal_default_instance() {
    return reinterpret_cast<const PointTriple*>(
               &_PointTriple_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(PointTriple* other);
  friend void swap(PointTriple& a, PointTriple& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PointTriple* New() const final {
    return CreateMaybeMessage<PointTriple>(nullptr);
  }

  PointTriple* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PointTriple>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PointTriple& from);
  void MergeFrom(const PointTriple& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointTriple* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .lidar_algorithm.common.proto.Point2D left = 1;
  bool has_left() const;
  void clear_left();
  static const int kLeftFieldNumber = 1;
  const ::lidar_algorithm::common::proto::Point2D& left() const;
  ::lidar_algorithm::common::proto::Point2D* release_left();
  ::lidar_algorithm::common::proto::Point2D* mutable_left();
  void set_allocated_left(::lidar_algorithm::common::proto::Point2D* left);

  // .lidar_algorithm.common.proto.Point2D middle = 2;
  bool has_middle() const;
  void clear_middle();
  static const int kMiddleFieldNumber = 2;
  const ::lidar_algorithm::common::proto::Point2D& middle() const;
  ::lidar_algorithm::common::proto::Point2D* release_middle();
  ::lidar_algorithm::common::proto::Point2D* mutable_middle();
  void set_allocated_middle(::lidar_algorithm::common::proto::Point2D* middle);

  // .lidar_algorithm.common.proto.Point2D right = 3;
  bool has_right() const;
  void clear_right();
  static const int kRightFieldNumber = 3;
  const ::lidar_algorithm::common::proto::Point2D& right() const;
  ::lidar_algorithm::common::proto::Point2D* release_right();
  ::lidar_algorithm::common::proto::Point2D* mutable_right();
  void set_allocated_right(::lidar_algorithm::common::proto::Point2D* right);

  // @@protoc_insertion_point(class_scope:lidar_algorithm.common.proto.PointTriple)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::lidar_algorithm::common::proto::Point2D* left_;
  ::lidar_algorithm::common::proto::Point2D* middle_;
  ::lidar_algorithm::common::proto::Point2D* right_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class Box2D :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lidar_algorithm.common.proto.Box2D) */ {
 public:
  Box2D();
  virtual ~Box2D();

  Box2D(const Box2D& from);

  inline Box2D& operator=(const Box2D& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Box2D(Box2D&& from) noexcept
    : Box2D() {
    *this = ::std::move(from);
  }

  inline Box2D& operator=(Box2D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Box2D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Box2D* internal_default_instance() {
    return reinterpret_cast<const Box2D*>(
               &_Box2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Box2D* other);
  friend void swap(Box2D& a, Box2D& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Box2D* New() const final {
    return CreateMaybeMessage<Box2D>(nullptr);
  }

  Box2D* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Box2D>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Box2D& from);
  void MergeFrom(const Box2D& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Box2D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // double y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // double height = 3;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  double height() const;
  void set_height(double value);

  // double width = 4;
  void clear_width();
  static const int kWidthFieldNumber = 4;
  double width() const;
  void set_width(double value);

  // @@protoc_insertion_point(class_scope:lidar_algorithm.common.proto.Box2D)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double x_;
  double y_;
  double height_;
  double width_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class Box3D :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lidar_algorithm.common.proto.Box3D) */ {
 public:
  Box3D();
  virtual ~Box3D();

  Box3D(const Box3D& from);

  inline Box3D& operator=(const Box3D& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Box3D(Box3D&& from) noexcept
    : Box3D() {
    *this = ::std::move(from);
  }

  inline Box3D& operator=(Box3D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Box3D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Box3D* internal_default_instance() {
    return reinterpret_cast<const Box3D*>(
               &_Box3D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Box3D* other);
  friend void swap(Box3D& a, Box3D& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Box3D* New() const final {
    return CreateMaybeMessage<Box3D>(nullptr);
  }

  Box3D* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Box3D>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Box3D& from);
  void MergeFrom(const Box3D& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Box3D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // double y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // double z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // double length = 4;
  void clear_length();
  static const int kLengthFieldNumber = 4;
  double length() const;
  void set_length(double value);

  // double width = 5;
  void clear_width();
  static const int kWidthFieldNumber = 5;
  double width() const;
  void set_width(double value);

  // double height = 6;
  void clear_height();
  static const int kHeightFieldNumber = 6;
  double height() const;
  void set_height(double value);

  // @@protoc_insertion_point(class_scope:lidar_algorithm.common.proto.Box3D)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double x_;
  double y_;
  double z_;
  double length_;
  double width_;
  double height_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class PathLines :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lidar_algorithm.common.proto.PathLines) */ {
 public:
  PathLines();
  virtual ~PathLines();

  PathLines(const PathLines& from);

  inline PathLines& operator=(const PathLines& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PathLines(PathLines&& from) noexcept
    : PathLines() {
    *this = ::std::move(from);
  }

  inline PathLines& operator=(PathLines&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PathLines& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PathLines* internal_default_instance() {
    return reinterpret_cast<const PathLines*>(
               &_PathLines_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(PathLines* other);
  friend void swap(PathLines& a, PathLines& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PathLines* New() const final {
    return CreateMaybeMessage<PathLines>(nullptr);
  }

  PathLines* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PathLines>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PathLines& from);
  void MergeFrom(const PathLines& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathLines* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .lidar_algorithm.common.proto.Point2D left_line_2 = 1;
  int left_line_2_size() const;
  void clear_left_line_2();
  static const int kLeftLine2FieldNumber = 1;
  ::lidar_algorithm::common::proto::Point2D* mutable_left_line_2(int index);
  ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point2D >*
      mutable_left_line_2();
  const ::lidar_algorithm::common::proto::Point2D& left_line_2(int index) const;
  ::lidar_algorithm::common::proto::Point2D* add_left_line_2();
  const ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point2D >&
      left_line_2() const;

  // repeated .lidar_algorithm.common.proto.Point2D left_line_1 = 2;
  int left_line_1_size() const;
  void clear_left_line_1();
  static const int kLeftLine1FieldNumber = 2;
  ::lidar_algorithm::common::proto::Point2D* mutable_left_line_1(int index);
  ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point2D >*
      mutable_left_line_1();
  const ::lidar_algorithm::common::proto::Point2D& left_line_1(int index) const;
  ::lidar_algorithm::common::proto::Point2D* add_left_line_1();
  const ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point2D >&
      left_line_1() const;

  // repeated .lidar_algorithm.common.proto.Point2D line = 3;
  int line_size() const;
  void clear_line();
  static const int kLineFieldNumber = 3;
  ::lidar_algorithm::common::proto::Point2D* mutable_line(int index);
  ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point2D >*
      mutable_line();
  const ::lidar_algorithm::common::proto::Point2D& line(int index) const;
  ::lidar_algorithm::common::proto::Point2D* add_line();
  const ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point2D >&
      line() const;

  // repeated .lidar_algorithm.common.proto.Point2D right_line_1 = 4;
  int right_line_1_size() const;
  void clear_right_line_1();
  static const int kRightLine1FieldNumber = 4;
  ::lidar_algorithm::common::proto::Point2D* mutable_right_line_1(int index);
  ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point2D >*
      mutable_right_line_1();
  const ::lidar_algorithm::common::proto::Point2D& right_line_1(int index) const;
  ::lidar_algorithm::common::proto::Point2D* add_right_line_1();
  const ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point2D >&
      right_line_1() const;

  // repeated .lidar_algorithm.common.proto.Point2D right_line_2 = 5;
  int right_line_2_size() const;
  void clear_right_line_2();
  static const int kRightLine2FieldNumber = 5;
  ::lidar_algorithm::common::proto::Point2D* mutable_right_line_2(int index);
  ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point2D >*
      mutable_right_line_2();
  const ::lidar_algorithm::common::proto::Point2D& right_line_2(int index) const;
  ::lidar_algorithm::common::proto::Point2D* add_right_line_2();
  const ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point2D >&
      right_line_2() const;

  // @@protoc_insertion_point(class_scope:lidar_algorithm.common.proto.PathLines)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point2D > left_line_2_;
  ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point2D > left_line_1_;
  ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point2D > line_;
  ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point2D > right_line_1_;
  ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point2D > right_line_2_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class ObsOccuPathPct :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lidar_algorithm.common.proto.ObsOccuPathPct) */ {
 public:
  ObsOccuPathPct();
  virtual ~ObsOccuPathPct();

  ObsOccuPathPct(const ObsOccuPathPct& from);

  inline ObsOccuPathPct& operator=(const ObsOccuPathPct& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObsOccuPathPct(ObsOccuPathPct&& from) noexcept
    : ObsOccuPathPct() {
    *this = ::std::move(from);
  }

  inline ObsOccuPathPct& operator=(ObsOccuPathPct&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ObsOccuPathPct& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObsOccuPathPct* internal_default_instance() {
    return reinterpret_cast<const ObsOccuPathPct*>(
               &_ObsOccuPathPct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ObsOccuPathPct* other);
  friend void swap(ObsOccuPathPct& a, ObsOccuPathPct& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObsOccuPathPct* New() const final {
    return CreateMaybeMessage<ObsOccuPathPct>(nullptr);
  }

  ObsOccuPathPct* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObsOccuPathPct>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObsOccuPathPct& from);
  void MergeFrom(const ObsOccuPathPct& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObsOccuPathPct* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 left_pct = 1;
  void clear_left_pct();
  static const int kLeftPctFieldNumber = 1;
  ::google::protobuf::int32 left_pct() const;
  void set_left_pct(::google::protobuf::int32 value);

  // int32 right_pct = 2;
  void clear_right_pct();
  static const int kRightPctFieldNumber = 2;
  ::google::protobuf::int32 right_pct() const;
  void set_right_pct(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:lidar_algorithm.common.proto.ObsOccuPathPct)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 left_pct_;
  ::google::protobuf::int32 right_pct_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class PointXYZIL :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lidar_algorithm.common.proto.PointXYZIL) */ {
 public:
  PointXYZIL();
  virtual ~PointXYZIL();

  PointXYZIL(const PointXYZIL& from);

  inline PointXYZIL& operator=(const PointXYZIL& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PointXYZIL(PointXYZIL&& from) noexcept
    : PointXYZIL() {
    *this = ::std::move(from);
  }

  inline PointXYZIL& operator=(PointXYZIL&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PointXYZIL& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PointXYZIL* internal_default_instance() {
    return reinterpret_cast<const PointXYZIL*>(
               &_PointXYZIL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(PointXYZIL* other);
  friend void swap(PointXYZIL& a, PointXYZIL& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PointXYZIL* New() const final {
    return CreateMaybeMessage<PointXYZIL>(nullptr);
  }

  PointXYZIL* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PointXYZIL>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PointXYZIL& from);
  void MergeFrom(const PointXYZIL& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointXYZIL* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // double y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // double z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // double intensity = 4;
  void clear_intensity();
  static const int kIntensityFieldNumber = 4;
  double intensity() const;
  void set_intensity(double value);

  // uint32 label = 5;
  void clear_label();
  static const int kLabelFieldNumber = 5;
  ::google::protobuf::uint32 label() const;
  void set_label(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:lidar_algorithm.common.proto.PointXYZIL)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double x_;
  double y_;
  double z_;
  double intensity_;
  ::google::protobuf::uint32 label_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class PointCloud :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lidar_algorithm.common.proto.PointCloud) */ {
 public:
  PointCloud();
  virtual ~PointCloud();

  PointCloud(const PointCloud& from);

  inline PointCloud& operator=(const PointCloud& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PointCloud(PointCloud&& from) noexcept
    : PointCloud() {
    *this = ::std::move(from);
  }

  inline PointCloud& operator=(PointCloud&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PointCloud& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PointCloud* internal_default_instance() {
    return reinterpret_cast<const PointCloud*>(
               &_PointCloud_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(PointCloud* other);
  friend void swap(PointCloud& a, PointCloud& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PointCloud* New() const final {
    return CreateMaybeMessage<PointCloud>(nullptr);
  }

  PointCloud* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PointCloud>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PointCloud& from);
  void MergeFrom(const PointCloud& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointCloud* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .lidar_algorithm.common.proto.PointXYZIL points = 2;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 2;
  ::lidar_algorithm::common::proto::PointXYZIL* mutable_points(int index);
  ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::PointXYZIL >*
      mutable_points();
  const ::lidar_algorithm::common::proto::PointXYZIL& points(int index) const;
  ::lidar_algorithm::common::proto::PointXYZIL* add_points();
  const ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::PointXYZIL >&
      points() const;

  // int64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:lidar_algorithm.common.proto.PointCloud)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::PointXYZIL > points_;
  ::google::protobuf::int64 timestamp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class Quaternion :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lidar_algorithm.common.proto.Quaternion) */ {
 public:
  Quaternion();
  virtual ~Quaternion();

  Quaternion(const Quaternion& from);

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Quaternion(Quaternion&& from) noexcept
    : Quaternion() {
    *this = ::std::move(from);
  }

  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Quaternion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Quaternion* other);
  friend void swap(Quaternion& a, Quaternion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Quaternion* New() const final {
    return CreateMaybeMessage<Quaternion>(nullptr);
  }

  Quaternion* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Quaternion>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Quaternion& from);
  void MergeFrom(const Quaternion& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quaternion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double w = 1;
  void clear_w();
  static const int kWFieldNumber = 1;
  double w() const;
  void set_w(double value);

  // double x = 2;
  void clear_x();
  static const int kXFieldNumber = 2;
  double x() const;
  void set_x(double value);

  // double y = 3;
  void clear_y();
  static const int kYFieldNumber = 3;
  double y() const;
  void set_y(double value);

  // double z = 4;
  void clear_z();
  static const int kZFieldNumber = 4;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:lidar_algorithm.common.proto.Quaternion)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double w_;
  double x_;
  double y_;
  double z_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class AABB3D :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lidar_algorithm.common.proto.AABB3D) */ {
 public:
  AABB3D();
  virtual ~AABB3D();

  AABB3D(const AABB3D& from);

  inline AABB3D& operator=(const AABB3D& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AABB3D(AABB3D&& from) noexcept
    : AABB3D() {
    *this = ::std::move(from);
  }

  inline AABB3D& operator=(AABB3D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const AABB3D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AABB3D* internal_default_instance() {
    return reinterpret_cast<const AABB3D*>(
               &_AABB3D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(AABB3D* other);
  friend void swap(AABB3D& a, AABB3D& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AABB3D* New() const final {
    return CreateMaybeMessage<AABB3D>(nullptr);
  }

  AABB3D* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AABB3D>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AABB3D& from);
  void MergeFrom(const AABB3D& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AABB3D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .lidar_algorithm.common.proto.Point3D min_point = 1;
  bool has_min_point() const;
  void clear_min_point();
  static const int kMinPointFieldNumber = 1;
  const ::lidar_algorithm::common::proto::Point3D& min_point() const;
  ::lidar_algorithm::common::proto::Point3D* release_min_point();
  ::lidar_algorithm::common::proto::Point3D* mutable_min_point();
  void set_allocated_min_point(::lidar_algorithm::common::proto::Point3D* min_point);

  // .lidar_algorithm.common.proto.Point3D max_point = 2;
  bool has_max_point() const;
  void clear_max_point();
  static const int kMaxPointFieldNumber = 2;
  const ::lidar_algorithm::common::proto::Point3D& max_point() const;
  ::lidar_algorithm::common::proto::Point3D* release_max_point();
  ::lidar_algorithm::common::proto::Point3D* mutable_max_point();
  void set_allocated_max_point(::lidar_algorithm::common::proto::Point3D* max_point);

  // @@protoc_insertion_point(class_scope:lidar_algorithm.common.proto.AABB3D)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::lidar_algorithm::common::proto::Point3D* min_point_;
  ::lidar_algorithm::common::proto::Point3D* max_point_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class AABB3Ds :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lidar_algorithm.common.proto.AABB3Ds) */ {
 public:
  AABB3Ds();
  virtual ~AABB3Ds();

  AABB3Ds(const AABB3Ds& from);

  inline AABB3Ds& operator=(const AABB3Ds& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AABB3Ds(AABB3Ds&& from) noexcept
    : AABB3Ds() {
    *this = ::std::move(from);
  }

  inline AABB3Ds& operator=(AABB3Ds&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const AABB3Ds& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AABB3Ds* internal_default_instance() {
    return reinterpret_cast<const AABB3Ds*>(
               &_AABB3Ds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(AABB3Ds* other);
  friend void swap(AABB3Ds& a, AABB3Ds& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AABB3Ds* New() const final {
    return CreateMaybeMessage<AABB3Ds>(nullptr);
  }

  AABB3Ds* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AABB3Ds>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AABB3Ds& from);
  void MergeFrom(const AABB3Ds& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AABB3Ds* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .lidar_algorithm.common.proto.AABB3D aabb3ds = 1;
  int aabb3ds_size() const;
  void clear_aabb3ds();
  static const int kAabb3DsFieldNumber = 1;
  ::lidar_algorithm::common::proto::AABB3D* mutable_aabb3ds(int index);
  ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::AABB3D >*
      mutable_aabb3ds();
  const ::lidar_algorithm::common::proto::AABB3D& aabb3ds(int index) const;
  ::lidar_algorithm::common::proto::AABB3D* add_aabb3ds();
  const ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::AABB3D >&
      aabb3ds() const;

  // @@protoc_insertion_point(class_scope:lidar_algorithm.common.proto.AABB3Ds)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::AABB3D > aabb3ds_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class OBB3D :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lidar_algorithm.common.proto.OBB3D) */ {
 public:
  OBB3D();
  virtual ~OBB3D();

  OBB3D(const OBB3D& from);

  inline OBB3D& operator=(const OBB3D& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OBB3D(OBB3D&& from) noexcept
    : OBB3D() {
    *this = ::std::move(from);
  }

  inline OBB3D& operator=(OBB3D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const OBB3D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OBB3D* internal_default_instance() {
    return reinterpret_cast<const OBB3D*>(
               &_OBB3D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(OBB3D* other);
  friend void swap(OBB3D& a, OBB3D& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OBB3D* New() const final {
    return CreateMaybeMessage<OBB3D>(nullptr);
  }

  OBB3D* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OBB3D>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OBB3D& from);
  void MergeFrom(const OBB3D& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OBB3D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .lidar_algorithm.common.proto.Point3D min_point = 1;
  bool has_min_point() const;
  void clear_min_point();
  static const int kMinPointFieldNumber = 1;
  const ::lidar_algorithm::common::proto::Point3D& min_point() const;
  ::lidar_algorithm::common::proto::Point3D* release_min_point();
  ::lidar_algorithm::common::proto::Point3D* mutable_min_point();
  void set_allocated_min_point(::lidar_algorithm::common::proto::Point3D* min_point);

  // .lidar_algorithm.common.proto.Point3D max_point = 2;
  bool has_max_point() const;
  void clear_max_point();
  static const int kMaxPointFieldNumber = 2;
  const ::lidar_algorithm::common::proto::Point3D& max_point() const;
  ::lidar_algorithm::common::proto::Point3D* release_max_point();
  ::lidar_algorithm::common::proto::Point3D* mutable_max_point();
  void set_allocated_max_point(::lidar_algorithm::common::proto::Point3D* max_point);

  // .lidar_algorithm.common.proto.Point3D position = 3;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  const ::lidar_algorithm::common::proto::Point3D& position() const;
  ::lidar_algorithm::common::proto::Point3D* release_position();
  ::lidar_algorithm::common::proto::Point3D* mutable_position();
  void set_allocated_position(::lidar_algorithm::common::proto::Point3D* position);

  // .lidar_algorithm.common.proto.Quaternion quat = 4;
  bool has_quat() const;
  void clear_quat();
  static const int kQuatFieldNumber = 4;
  const ::lidar_algorithm::common::proto::Quaternion& quat() const;
  ::lidar_algorithm::common::proto::Quaternion* release_quat();
  ::lidar_algorithm::common::proto::Quaternion* mutable_quat();
  void set_allocated_quat(::lidar_algorithm::common::proto::Quaternion* quat);

  // @@protoc_insertion_point(class_scope:lidar_algorithm.common.proto.OBB3D)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::lidar_algorithm::common::proto::Point3D* min_point_;
  ::lidar_algorithm::common::proto::Point3D* max_point_;
  ::lidar_algorithm::common::proto::Point3D* position_;
  ::lidar_algorithm::common::proto::Quaternion* quat_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class OBB3Ds :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lidar_algorithm.common.proto.OBB3Ds) */ {
 public:
  OBB3Ds();
  virtual ~OBB3Ds();

  OBB3Ds(const OBB3Ds& from);

  inline OBB3Ds& operator=(const OBB3Ds& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OBB3Ds(OBB3Ds&& from) noexcept
    : OBB3Ds() {
    *this = ::std::move(from);
  }

  inline OBB3Ds& operator=(OBB3Ds&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const OBB3Ds& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OBB3Ds* internal_default_instance() {
    return reinterpret_cast<const OBB3Ds*>(
               &_OBB3Ds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(OBB3Ds* other);
  friend void swap(OBB3Ds& a, OBB3Ds& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OBB3Ds* New() const final {
    return CreateMaybeMessage<OBB3Ds>(nullptr);
  }

  OBB3Ds* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OBB3Ds>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OBB3Ds& from);
  void MergeFrom(const OBB3Ds& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OBB3Ds* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .lidar_algorithm.common.proto.OBB3D obb3ds = 1;
  int obb3ds_size() const;
  void clear_obb3ds();
  static const int kObb3DsFieldNumber = 1;
  ::lidar_algorithm::common::proto::OBB3D* mutable_obb3ds(int index);
  ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::OBB3D >*
      mutable_obb3ds();
  const ::lidar_algorithm::common::proto::OBB3D& obb3ds(int index) const;
  ::lidar_algorithm::common::proto::OBB3D* add_obb3ds();
  const ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::OBB3D >&
      obb3ds() const;

  // @@protoc_insertion_point(class_scope:lidar_algorithm.common.proto.OBB3Ds)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::OBB3D > obb3ds_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class Cluster :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lidar_algorithm.common.proto.Cluster) */ {
 public:
  Cluster();
  virtual ~Cluster();

  Cluster(const Cluster& from);

  inline Cluster& operator=(const Cluster& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Cluster(Cluster&& from) noexcept
    : Cluster() {
    *this = ::std::move(from);
  }

  inline Cluster& operator=(Cluster&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Cluster& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Cluster* internal_default_instance() {
    return reinterpret_cast<const Cluster*>(
               &_Cluster_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(Cluster* other);
  friend void swap(Cluster& a, Cluster& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Cluster* New() const final {
    return CreateMaybeMessage<Cluster>(nullptr);
  }

  Cluster* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Cluster>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Cluster& from);
  void MergeFrom(const Cluster& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cluster* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .lidar_algorithm.common.proto.Point3D points = 1;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 1;
  ::lidar_algorithm::common::proto::Point3D* mutable_points(int index);
  ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point3D >*
      mutable_points();
  const ::lidar_algorithm::common::proto::Point3D& points(int index) const;
  ::lidar_algorithm::common::proto::Point3D* add_points();
  const ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point3D >&
      points() const;

  // @@protoc_insertion_point(class_scope:lidar_algorithm.common.proto.Cluster)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point3D > points_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// -------------------------------------------------------------------

class Clusters :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lidar_algorithm.common.proto.Clusters) */ {
 public:
  Clusters();
  virtual ~Clusters();

  Clusters(const Clusters& from);

  inline Clusters& operator=(const Clusters& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Clusters(Clusters&& from) noexcept
    : Clusters() {
    *this = ::std::move(from);
  }

  inline Clusters& operator=(Clusters&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Clusters& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Clusters* internal_default_instance() {
    return reinterpret_cast<const Clusters*>(
               &_Clusters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(Clusters* other);
  friend void swap(Clusters& a, Clusters& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Clusters* New() const final {
    return CreateMaybeMessage<Clusters>(nullptr);
  }

  Clusters* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Clusters>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Clusters& from);
  void MergeFrom(const Clusters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Clusters* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .lidar_algorithm.common.proto.Cluster clusters = 1;
  int clusters_size() const;
  void clear_clusters();
  static const int kClustersFieldNumber = 1;
  ::lidar_algorithm::common::proto::Cluster* mutable_clusters(int index);
  ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Cluster >*
      mutable_clusters();
  const ::lidar_algorithm::common::proto::Cluster& clusters(int index) const;
  ::lidar_algorithm::common::proto::Cluster* add_clusters();
  const ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Cluster >&
      clusters() const;

  // @@protoc_insertion_point(class_scope:lidar_algorithm.common.proto.Clusters)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Cluster > clusters_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_geometry_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Point2D

// double x = 1;
inline void Point2D::clear_x() {
  x_ = 0;
}
inline double Point2D::x() const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.Point2D.x)
  return x_;
}
inline void Point2D::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:lidar_algorithm.common.proto.Point2D.x)
}

// double y = 2;
inline void Point2D::clear_y() {
  y_ = 0;
}
inline double Point2D::y() const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.Point2D.y)
  return y_;
}
inline void Point2D::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:lidar_algorithm.common.proto.Point2D.y)
}

// -------------------------------------------------------------------

// Point3D

// double x = 1;
inline void Point3D::clear_x() {
  x_ = 0;
}
inline double Point3D::x() const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.Point3D.x)
  return x_;
}
inline void Point3D::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:lidar_algorithm.common.proto.Point3D.x)
}

// double y = 2;
inline void Point3D::clear_y() {
  y_ = 0;
}
inline double Point3D::y() const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.Point3D.y)
  return y_;
}
inline void Point3D::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:lidar_algorithm.common.proto.Point3D.y)
}

// double z = 3;
inline void Point3D::clear_z() {
  z_ = 0;
}
inline double Point3D::z() const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.Point3D.z)
  return z_;
}
inline void Point3D::set_z(double value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:lidar_algorithm.common.proto.Point3D.z)
}

// -------------------------------------------------------------------

// Polygon

// repeated .lidar_algorithm.common.proto.Point3D points = 1;
inline int Polygon::points_size() const {
  return points_.size();
}
inline void Polygon::clear_points() {
  points_.Clear();
}
inline ::lidar_algorithm::common::proto::Point3D* Polygon::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:lidar_algorithm.common.proto.Polygon.points)
  return points_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point3D >*
Polygon::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:lidar_algorithm.common.proto.Polygon.points)
  return &points_;
}
inline const ::lidar_algorithm::common::proto::Point3D& Polygon::points(int index) const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.Polygon.points)
  return points_.Get(index);
}
inline ::lidar_algorithm::common::proto::Point3D* Polygon::add_points() {
  // @@protoc_insertion_point(field_add:lidar_algorithm.common.proto.Polygon.points)
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point3D >&
Polygon::points() const {
  // @@protoc_insertion_point(field_list:lidar_algorithm.common.proto.Polygon.points)
  return points_;
}

// -------------------------------------------------------------------

// PointPair

// .lidar_algorithm.common.proto.Point2D left = 1;
inline bool PointPair::has_left() const {
  return this != internal_default_instance() && left_ != nullptr;
}
inline void PointPair::clear_left() {
  if (GetArenaNoVirtual() == nullptr && left_ != nullptr) {
    delete left_;
  }
  left_ = nullptr;
}
inline const ::lidar_algorithm::common::proto::Point2D& PointPair::left() const {
  const ::lidar_algorithm::common::proto::Point2D* p = left_;
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.PointPair.left)
  return p != nullptr ? *p : *reinterpret_cast<const ::lidar_algorithm::common::proto::Point2D*>(
      &::lidar_algorithm::common::proto::_Point2D_default_instance_);
}
inline ::lidar_algorithm::common::proto::Point2D* PointPair::release_left() {
  // @@protoc_insertion_point(field_release:lidar_algorithm.common.proto.PointPair.left)
  
  ::lidar_algorithm::common::proto::Point2D* temp = left_;
  left_ = nullptr;
  return temp;
}
inline ::lidar_algorithm::common::proto::Point2D* PointPair::mutable_left() {
  
  if (left_ == nullptr) {
    auto* p = CreateMaybeMessage<::lidar_algorithm::common::proto::Point2D>(GetArenaNoVirtual());
    left_ = p;
  }
  // @@protoc_insertion_point(field_mutable:lidar_algorithm.common.proto.PointPair.left)
  return left_;
}
inline void PointPair::set_allocated_left(::lidar_algorithm::common::proto::Point2D* left) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete left_;
  }
  if (left) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      left = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, left, submessage_arena);
    }
    
  } else {
    
  }
  left_ = left;
  // @@protoc_insertion_point(field_set_allocated:lidar_algorithm.common.proto.PointPair.left)
}

// .lidar_algorithm.common.proto.Point2D right = 2;
inline bool PointPair::has_right() const {
  return this != internal_default_instance() && right_ != nullptr;
}
inline void PointPair::clear_right() {
  if (GetArenaNoVirtual() == nullptr && right_ != nullptr) {
    delete right_;
  }
  right_ = nullptr;
}
inline const ::lidar_algorithm::common::proto::Point2D& PointPair::right() const {
  const ::lidar_algorithm::common::proto::Point2D* p = right_;
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.PointPair.right)
  return p != nullptr ? *p : *reinterpret_cast<const ::lidar_algorithm::common::proto::Point2D*>(
      &::lidar_algorithm::common::proto::_Point2D_default_instance_);
}
inline ::lidar_algorithm::common::proto::Point2D* PointPair::release_right() {
  // @@protoc_insertion_point(field_release:lidar_algorithm.common.proto.PointPair.right)
  
  ::lidar_algorithm::common::proto::Point2D* temp = right_;
  right_ = nullptr;
  return temp;
}
inline ::lidar_algorithm::common::proto::Point2D* PointPair::mutable_right() {
  
  if (right_ == nullptr) {
    auto* p = CreateMaybeMessage<::lidar_algorithm::common::proto::Point2D>(GetArenaNoVirtual());
    right_ = p;
  }
  // @@protoc_insertion_point(field_mutable:lidar_algorithm.common.proto.PointPair.right)
  return right_;
}
inline void PointPair::set_allocated_right(::lidar_algorithm::common::proto::Point2D* right) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete right_;
  }
  if (right) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      right = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, right, submessage_arena);
    }
    
  } else {
    
  }
  right_ = right;
  // @@protoc_insertion_point(field_set_allocated:lidar_algorithm.common.proto.PointPair.right)
}

// -------------------------------------------------------------------

// PointTriple

// .lidar_algorithm.common.proto.Point2D left = 1;
inline bool PointTriple::has_left() const {
  return this != internal_default_instance() && left_ != nullptr;
}
inline void PointTriple::clear_left() {
  if (GetArenaNoVirtual() == nullptr && left_ != nullptr) {
    delete left_;
  }
  left_ = nullptr;
}
inline const ::lidar_algorithm::common::proto::Point2D& PointTriple::left() const {
  const ::lidar_algorithm::common::proto::Point2D* p = left_;
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.PointTriple.left)
  return p != nullptr ? *p : *reinterpret_cast<const ::lidar_algorithm::common::proto::Point2D*>(
      &::lidar_algorithm::common::proto::_Point2D_default_instance_);
}
inline ::lidar_algorithm::common::proto::Point2D* PointTriple::release_left() {
  // @@protoc_insertion_point(field_release:lidar_algorithm.common.proto.PointTriple.left)
  
  ::lidar_algorithm::common::proto::Point2D* temp = left_;
  left_ = nullptr;
  return temp;
}
inline ::lidar_algorithm::common::proto::Point2D* PointTriple::mutable_left() {
  
  if (left_ == nullptr) {
    auto* p = CreateMaybeMessage<::lidar_algorithm::common::proto::Point2D>(GetArenaNoVirtual());
    left_ = p;
  }
  // @@protoc_insertion_point(field_mutable:lidar_algorithm.common.proto.PointTriple.left)
  return left_;
}
inline void PointTriple::set_allocated_left(::lidar_algorithm::common::proto::Point2D* left) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete left_;
  }
  if (left) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      left = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, left, submessage_arena);
    }
    
  } else {
    
  }
  left_ = left;
  // @@protoc_insertion_point(field_set_allocated:lidar_algorithm.common.proto.PointTriple.left)
}

// .lidar_algorithm.common.proto.Point2D middle = 2;
inline bool PointTriple::has_middle() const {
  return this != internal_default_instance() && middle_ != nullptr;
}
inline void PointTriple::clear_middle() {
  if (GetArenaNoVirtual() == nullptr && middle_ != nullptr) {
    delete middle_;
  }
  middle_ = nullptr;
}
inline const ::lidar_algorithm::common::proto::Point2D& PointTriple::middle() const {
  const ::lidar_algorithm::common::proto::Point2D* p = middle_;
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.PointTriple.middle)
  return p != nullptr ? *p : *reinterpret_cast<const ::lidar_algorithm::common::proto::Point2D*>(
      &::lidar_algorithm::common::proto::_Point2D_default_instance_);
}
inline ::lidar_algorithm::common::proto::Point2D* PointTriple::release_middle() {
  // @@protoc_insertion_point(field_release:lidar_algorithm.common.proto.PointTriple.middle)
  
  ::lidar_algorithm::common::proto::Point2D* temp = middle_;
  middle_ = nullptr;
  return temp;
}
inline ::lidar_algorithm::common::proto::Point2D* PointTriple::mutable_middle() {
  
  if (middle_ == nullptr) {
    auto* p = CreateMaybeMessage<::lidar_algorithm::common::proto::Point2D>(GetArenaNoVirtual());
    middle_ = p;
  }
  // @@protoc_insertion_point(field_mutable:lidar_algorithm.common.proto.PointTriple.middle)
  return middle_;
}
inline void PointTriple::set_allocated_middle(::lidar_algorithm::common::proto::Point2D* middle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete middle_;
  }
  if (middle) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      middle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, middle, submessage_arena);
    }
    
  } else {
    
  }
  middle_ = middle;
  // @@protoc_insertion_point(field_set_allocated:lidar_algorithm.common.proto.PointTriple.middle)
}

// .lidar_algorithm.common.proto.Point2D right = 3;
inline bool PointTriple::has_right() const {
  return this != internal_default_instance() && right_ != nullptr;
}
inline void PointTriple::clear_right() {
  if (GetArenaNoVirtual() == nullptr && right_ != nullptr) {
    delete right_;
  }
  right_ = nullptr;
}
inline const ::lidar_algorithm::common::proto::Point2D& PointTriple::right() const {
  const ::lidar_algorithm::common::proto::Point2D* p = right_;
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.PointTriple.right)
  return p != nullptr ? *p : *reinterpret_cast<const ::lidar_algorithm::common::proto::Point2D*>(
      &::lidar_algorithm::common::proto::_Point2D_default_instance_);
}
inline ::lidar_algorithm::common::proto::Point2D* PointTriple::release_right() {
  // @@protoc_insertion_point(field_release:lidar_algorithm.common.proto.PointTriple.right)
  
  ::lidar_algorithm::common::proto::Point2D* temp = right_;
  right_ = nullptr;
  return temp;
}
inline ::lidar_algorithm::common::proto::Point2D* PointTriple::mutable_right() {
  
  if (right_ == nullptr) {
    auto* p = CreateMaybeMessage<::lidar_algorithm::common::proto::Point2D>(GetArenaNoVirtual());
    right_ = p;
  }
  // @@protoc_insertion_point(field_mutable:lidar_algorithm.common.proto.PointTriple.right)
  return right_;
}
inline void PointTriple::set_allocated_right(::lidar_algorithm::common::proto::Point2D* right) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete right_;
  }
  if (right) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      right = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, right, submessage_arena);
    }
    
  } else {
    
  }
  right_ = right;
  // @@protoc_insertion_point(field_set_allocated:lidar_algorithm.common.proto.PointTriple.right)
}

// -------------------------------------------------------------------

// Box2D

// double x = 1;
inline void Box2D::clear_x() {
  x_ = 0;
}
inline double Box2D::x() const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.Box2D.x)
  return x_;
}
inline void Box2D::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:lidar_algorithm.common.proto.Box2D.x)
}

// double y = 2;
inline void Box2D::clear_y() {
  y_ = 0;
}
inline double Box2D::y() const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.Box2D.y)
  return y_;
}
inline void Box2D::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:lidar_algorithm.common.proto.Box2D.y)
}

// double height = 3;
inline void Box2D::clear_height() {
  height_ = 0;
}
inline double Box2D::height() const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.Box2D.height)
  return height_;
}
inline void Box2D::set_height(double value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:lidar_algorithm.common.proto.Box2D.height)
}

// double width = 4;
inline void Box2D::clear_width() {
  width_ = 0;
}
inline double Box2D::width() const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.Box2D.width)
  return width_;
}
inline void Box2D::set_width(double value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:lidar_algorithm.common.proto.Box2D.width)
}

// -------------------------------------------------------------------

// Box3D

// double x = 1;
inline void Box3D::clear_x() {
  x_ = 0;
}
inline double Box3D::x() const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.Box3D.x)
  return x_;
}
inline void Box3D::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:lidar_algorithm.common.proto.Box3D.x)
}

// double y = 2;
inline void Box3D::clear_y() {
  y_ = 0;
}
inline double Box3D::y() const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.Box3D.y)
  return y_;
}
inline void Box3D::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:lidar_algorithm.common.proto.Box3D.y)
}

// double z = 3;
inline void Box3D::clear_z() {
  z_ = 0;
}
inline double Box3D::z() const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.Box3D.z)
  return z_;
}
inline void Box3D::set_z(double value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:lidar_algorithm.common.proto.Box3D.z)
}

// double length = 4;
inline void Box3D::clear_length() {
  length_ = 0;
}
inline double Box3D::length() const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.Box3D.length)
  return length_;
}
inline void Box3D::set_length(double value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:lidar_algorithm.common.proto.Box3D.length)
}

// double width = 5;
inline void Box3D::clear_width() {
  width_ = 0;
}
inline double Box3D::width() const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.Box3D.width)
  return width_;
}
inline void Box3D::set_width(double value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:lidar_algorithm.common.proto.Box3D.width)
}

// double height = 6;
inline void Box3D::clear_height() {
  height_ = 0;
}
inline double Box3D::height() const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.Box3D.height)
  return height_;
}
inline void Box3D::set_height(double value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:lidar_algorithm.common.proto.Box3D.height)
}

// -------------------------------------------------------------------

// PathLines

// repeated .lidar_algorithm.common.proto.Point2D left_line_2 = 1;
inline int PathLines::left_line_2_size() const {
  return left_line_2_.size();
}
inline void PathLines::clear_left_line_2() {
  left_line_2_.Clear();
}
inline ::lidar_algorithm::common::proto::Point2D* PathLines::mutable_left_line_2(int index) {
  // @@protoc_insertion_point(field_mutable:lidar_algorithm.common.proto.PathLines.left_line_2)
  return left_line_2_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point2D >*
PathLines::mutable_left_line_2() {
  // @@protoc_insertion_point(field_mutable_list:lidar_algorithm.common.proto.PathLines.left_line_2)
  return &left_line_2_;
}
inline const ::lidar_algorithm::common::proto::Point2D& PathLines::left_line_2(int index) const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.PathLines.left_line_2)
  return left_line_2_.Get(index);
}
inline ::lidar_algorithm::common::proto::Point2D* PathLines::add_left_line_2() {
  // @@protoc_insertion_point(field_add:lidar_algorithm.common.proto.PathLines.left_line_2)
  return left_line_2_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point2D >&
PathLines::left_line_2() const {
  // @@protoc_insertion_point(field_list:lidar_algorithm.common.proto.PathLines.left_line_2)
  return left_line_2_;
}

// repeated .lidar_algorithm.common.proto.Point2D left_line_1 = 2;
inline int PathLines::left_line_1_size() const {
  return left_line_1_.size();
}
inline void PathLines::clear_left_line_1() {
  left_line_1_.Clear();
}
inline ::lidar_algorithm::common::proto::Point2D* PathLines::mutable_left_line_1(int index) {
  // @@protoc_insertion_point(field_mutable:lidar_algorithm.common.proto.PathLines.left_line_1)
  return left_line_1_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point2D >*
PathLines::mutable_left_line_1() {
  // @@protoc_insertion_point(field_mutable_list:lidar_algorithm.common.proto.PathLines.left_line_1)
  return &left_line_1_;
}
inline const ::lidar_algorithm::common::proto::Point2D& PathLines::left_line_1(int index) const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.PathLines.left_line_1)
  return left_line_1_.Get(index);
}
inline ::lidar_algorithm::common::proto::Point2D* PathLines::add_left_line_1() {
  // @@protoc_insertion_point(field_add:lidar_algorithm.common.proto.PathLines.left_line_1)
  return left_line_1_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point2D >&
PathLines::left_line_1() const {
  // @@protoc_insertion_point(field_list:lidar_algorithm.common.proto.PathLines.left_line_1)
  return left_line_1_;
}

// repeated .lidar_algorithm.common.proto.Point2D line = 3;
inline int PathLines::line_size() const {
  return line_.size();
}
inline void PathLines::clear_line() {
  line_.Clear();
}
inline ::lidar_algorithm::common::proto::Point2D* PathLines::mutable_line(int index) {
  // @@protoc_insertion_point(field_mutable:lidar_algorithm.common.proto.PathLines.line)
  return line_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point2D >*
PathLines::mutable_line() {
  // @@protoc_insertion_point(field_mutable_list:lidar_algorithm.common.proto.PathLines.line)
  return &line_;
}
inline const ::lidar_algorithm::common::proto::Point2D& PathLines::line(int index) const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.PathLines.line)
  return line_.Get(index);
}
inline ::lidar_algorithm::common::proto::Point2D* PathLines::add_line() {
  // @@protoc_insertion_point(field_add:lidar_algorithm.common.proto.PathLines.line)
  return line_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point2D >&
PathLines::line() const {
  // @@protoc_insertion_point(field_list:lidar_algorithm.common.proto.PathLines.line)
  return line_;
}

// repeated .lidar_algorithm.common.proto.Point2D right_line_1 = 4;
inline int PathLines::right_line_1_size() const {
  return right_line_1_.size();
}
inline void PathLines::clear_right_line_1() {
  right_line_1_.Clear();
}
inline ::lidar_algorithm::common::proto::Point2D* PathLines::mutable_right_line_1(int index) {
  // @@protoc_insertion_point(field_mutable:lidar_algorithm.common.proto.PathLines.right_line_1)
  return right_line_1_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point2D >*
PathLines::mutable_right_line_1() {
  // @@protoc_insertion_point(field_mutable_list:lidar_algorithm.common.proto.PathLines.right_line_1)
  return &right_line_1_;
}
inline const ::lidar_algorithm::common::proto::Point2D& PathLines::right_line_1(int index) const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.PathLines.right_line_1)
  return right_line_1_.Get(index);
}
inline ::lidar_algorithm::common::proto::Point2D* PathLines::add_right_line_1() {
  // @@protoc_insertion_point(field_add:lidar_algorithm.common.proto.PathLines.right_line_1)
  return right_line_1_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point2D >&
PathLines::right_line_1() const {
  // @@protoc_insertion_point(field_list:lidar_algorithm.common.proto.PathLines.right_line_1)
  return right_line_1_;
}

// repeated .lidar_algorithm.common.proto.Point2D right_line_2 = 5;
inline int PathLines::right_line_2_size() const {
  return right_line_2_.size();
}
inline void PathLines::clear_right_line_2() {
  right_line_2_.Clear();
}
inline ::lidar_algorithm::common::proto::Point2D* PathLines::mutable_right_line_2(int index) {
  // @@protoc_insertion_point(field_mutable:lidar_algorithm.common.proto.PathLines.right_line_2)
  return right_line_2_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point2D >*
PathLines::mutable_right_line_2() {
  // @@protoc_insertion_point(field_mutable_list:lidar_algorithm.common.proto.PathLines.right_line_2)
  return &right_line_2_;
}
inline const ::lidar_algorithm::common::proto::Point2D& PathLines::right_line_2(int index) const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.PathLines.right_line_2)
  return right_line_2_.Get(index);
}
inline ::lidar_algorithm::common::proto::Point2D* PathLines::add_right_line_2() {
  // @@protoc_insertion_point(field_add:lidar_algorithm.common.proto.PathLines.right_line_2)
  return right_line_2_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point2D >&
PathLines::right_line_2() const {
  // @@protoc_insertion_point(field_list:lidar_algorithm.common.proto.PathLines.right_line_2)
  return right_line_2_;
}

// -------------------------------------------------------------------

// ObsOccuPathPct

// int32 left_pct = 1;
inline void ObsOccuPathPct::clear_left_pct() {
  left_pct_ = 0;
}
inline ::google::protobuf::int32 ObsOccuPathPct::left_pct() const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.ObsOccuPathPct.left_pct)
  return left_pct_;
}
inline void ObsOccuPathPct::set_left_pct(::google::protobuf::int32 value) {
  
  left_pct_ = value;
  // @@protoc_insertion_point(field_set:lidar_algorithm.common.proto.ObsOccuPathPct.left_pct)
}

// int32 right_pct = 2;
inline void ObsOccuPathPct::clear_right_pct() {
  right_pct_ = 0;
}
inline ::google::protobuf::int32 ObsOccuPathPct::right_pct() const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.ObsOccuPathPct.right_pct)
  return right_pct_;
}
inline void ObsOccuPathPct::set_right_pct(::google::protobuf::int32 value) {
  
  right_pct_ = value;
  // @@protoc_insertion_point(field_set:lidar_algorithm.common.proto.ObsOccuPathPct.right_pct)
}

// -------------------------------------------------------------------

// PointXYZIL

// double x = 1;
inline void PointXYZIL::clear_x() {
  x_ = 0;
}
inline double PointXYZIL::x() const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.PointXYZIL.x)
  return x_;
}
inline void PointXYZIL::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:lidar_algorithm.common.proto.PointXYZIL.x)
}

// double y = 2;
inline void PointXYZIL::clear_y() {
  y_ = 0;
}
inline double PointXYZIL::y() const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.PointXYZIL.y)
  return y_;
}
inline void PointXYZIL::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:lidar_algorithm.common.proto.PointXYZIL.y)
}

// double z = 3;
inline void PointXYZIL::clear_z() {
  z_ = 0;
}
inline double PointXYZIL::z() const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.PointXYZIL.z)
  return z_;
}
inline void PointXYZIL::set_z(double value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:lidar_algorithm.common.proto.PointXYZIL.z)
}

// double intensity = 4;
inline void PointXYZIL::clear_intensity() {
  intensity_ = 0;
}
inline double PointXYZIL::intensity() const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.PointXYZIL.intensity)
  return intensity_;
}
inline void PointXYZIL::set_intensity(double value) {
  
  intensity_ = value;
  // @@protoc_insertion_point(field_set:lidar_algorithm.common.proto.PointXYZIL.intensity)
}

// uint32 label = 5;
inline void PointXYZIL::clear_label() {
  label_ = 0u;
}
inline ::google::protobuf::uint32 PointXYZIL::label() const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.PointXYZIL.label)
  return label_;
}
inline void PointXYZIL::set_label(::google::protobuf::uint32 value) {
  
  label_ = value;
  // @@protoc_insertion_point(field_set:lidar_algorithm.common.proto.PointXYZIL.label)
}

// -------------------------------------------------------------------

// PointCloud

// int64 timestamp = 1;
inline void PointCloud::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 PointCloud::timestamp() const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.PointCloud.timestamp)
  return timestamp_;
}
inline void PointCloud::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:lidar_algorithm.common.proto.PointCloud.timestamp)
}

// repeated .lidar_algorithm.common.proto.PointXYZIL points = 2;
inline int PointCloud::points_size() const {
  return points_.size();
}
inline void PointCloud::clear_points() {
  points_.Clear();
}
inline ::lidar_algorithm::common::proto::PointXYZIL* PointCloud::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:lidar_algorithm.common.proto.PointCloud.points)
  return points_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::PointXYZIL >*
PointCloud::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:lidar_algorithm.common.proto.PointCloud.points)
  return &points_;
}
inline const ::lidar_algorithm::common::proto::PointXYZIL& PointCloud::points(int index) const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.PointCloud.points)
  return points_.Get(index);
}
inline ::lidar_algorithm::common::proto::PointXYZIL* PointCloud::add_points() {
  // @@protoc_insertion_point(field_add:lidar_algorithm.common.proto.PointCloud.points)
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::PointXYZIL >&
PointCloud::points() const {
  // @@protoc_insertion_point(field_list:lidar_algorithm.common.proto.PointCloud.points)
  return points_;
}

// -------------------------------------------------------------------

// Quaternion

// double w = 1;
inline void Quaternion::clear_w() {
  w_ = 0;
}
inline double Quaternion::w() const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.Quaternion.w)
  return w_;
}
inline void Quaternion::set_w(double value) {
  
  w_ = value;
  // @@protoc_insertion_point(field_set:lidar_algorithm.common.proto.Quaternion.w)
}

// double x = 2;
inline void Quaternion::clear_x() {
  x_ = 0;
}
inline double Quaternion::x() const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.Quaternion.x)
  return x_;
}
inline void Quaternion::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:lidar_algorithm.common.proto.Quaternion.x)
}

// double y = 3;
inline void Quaternion::clear_y() {
  y_ = 0;
}
inline double Quaternion::y() const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.Quaternion.y)
  return y_;
}
inline void Quaternion::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:lidar_algorithm.common.proto.Quaternion.y)
}

// double z = 4;
inline void Quaternion::clear_z() {
  z_ = 0;
}
inline double Quaternion::z() const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.Quaternion.z)
  return z_;
}
inline void Quaternion::set_z(double value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:lidar_algorithm.common.proto.Quaternion.z)
}

// -------------------------------------------------------------------

// AABB3D

// .lidar_algorithm.common.proto.Point3D min_point = 1;
inline bool AABB3D::has_min_point() const {
  return this != internal_default_instance() && min_point_ != nullptr;
}
inline void AABB3D::clear_min_point() {
  if (GetArenaNoVirtual() == nullptr && min_point_ != nullptr) {
    delete min_point_;
  }
  min_point_ = nullptr;
}
inline const ::lidar_algorithm::common::proto::Point3D& AABB3D::min_point() const {
  const ::lidar_algorithm::common::proto::Point3D* p = min_point_;
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.AABB3D.min_point)
  return p != nullptr ? *p : *reinterpret_cast<const ::lidar_algorithm::common::proto::Point3D*>(
      &::lidar_algorithm::common::proto::_Point3D_default_instance_);
}
inline ::lidar_algorithm::common::proto::Point3D* AABB3D::release_min_point() {
  // @@protoc_insertion_point(field_release:lidar_algorithm.common.proto.AABB3D.min_point)
  
  ::lidar_algorithm::common::proto::Point3D* temp = min_point_;
  min_point_ = nullptr;
  return temp;
}
inline ::lidar_algorithm::common::proto::Point3D* AABB3D::mutable_min_point() {
  
  if (min_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::lidar_algorithm::common::proto::Point3D>(GetArenaNoVirtual());
    min_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:lidar_algorithm.common.proto.AABB3D.min_point)
  return min_point_;
}
inline void AABB3D::set_allocated_min_point(::lidar_algorithm::common::proto::Point3D* min_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete min_point_;
  }
  if (min_point) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      min_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, min_point, submessage_arena);
    }
    
  } else {
    
  }
  min_point_ = min_point;
  // @@protoc_insertion_point(field_set_allocated:lidar_algorithm.common.proto.AABB3D.min_point)
}

// .lidar_algorithm.common.proto.Point3D max_point = 2;
inline bool AABB3D::has_max_point() const {
  return this != internal_default_instance() && max_point_ != nullptr;
}
inline void AABB3D::clear_max_point() {
  if (GetArenaNoVirtual() == nullptr && max_point_ != nullptr) {
    delete max_point_;
  }
  max_point_ = nullptr;
}
inline const ::lidar_algorithm::common::proto::Point3D& AABB3D::max_point() const {
  const ::lidar_algorithm::common::proto::Point3D* p = max_point_;
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.AABB3D.max_point)
  return p != nullptr ? *p : *reinterpret_cast<const ::lidar_algorithm::common::proto::Point3D*>(
      &::lidar_algorithm::common::proto::_Point3D_default_instance_);
}
inline ::lidar_algorithm::common::proto::Point3D* AABB3D::release_max_point() {
  // @@protoc_insertion_point(field_release:lidar_algorithm.common.proto.AABB3D.max_point)
  
  ::lidar_algorithm::common::proto::Point3D* temp = max_point_;
  max_point_ = nullptr;
  return temp;
}
inline ::lidar_algorithm::common::proto::Point3D* AABB3D::mutable_max_point() {
  
  if (max_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::lidar_algorithm::common::proto::Point3D>(GetArenaNoVirtual());
    max_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:lidar_algorithm.common.proto.AABB3D.max_point)
  return max_point_;
}
inline void AABB3D::set_allocated_max_point(::lidar_algorithm::common::proto::Point3D* max_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete max_point_;
  }
  if (max_point) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      max_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, max_point, submessage_arena);
    }
    
  } else {
    
  }
  max_point_ = max_point;
  // @@protoc_insertion_point(field_set_allocated:lidar_algorithm.common.proto.AABB3D.max_point)
}

// -------------------------------------------------------------------

// AABB3Ds

// repeated .lidar_algorithm.common.proto.AABB3D aabb3ds = 1;
inline int AABB3Ds::aabb3ds_size() const {
  return aabb3ds_.size();
}
inline void AABB3Ds::clear_aabb3ds() {
  aabb3ds_.Clear();
}
inline ::lidar_algorithm::common::proto::AABB3D* AABB3Ds::mutable_aabb3ds(int index) {
  // @@protoc_insertion_point(field_mutable:lidar_algorithm.common.proto.AABB3Ds.aabb3ds)
  return aabb3ds_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::AABB3D >*
AABB3Ds::mutable_aabb3ds() {
  // @@protoc_insertion_point(field_mutable_list:lidar_algorithm.common.proto.AABB3Ds.aabb3ds)
  return &aabb3ds_;
}
inline const ::lidar_algorithm::common::proto::AABB3D& AABB3Ds::aabb3ds(int index) const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.AABB3Ds.aabb3ds)
  return aabb3ds_.Get(index);
}
inline ::lidar_algorithm::common::proto::AABB3D* AABB3Ds::add_aabb3ds() {
  // @@protoc_insertion_point(field_add:lidar_algorithm.common.proto.AABB3Ds.aabb3ds)
  return aabb3ds_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::AABB3D >&
AABB3Ds::aabb3ds() const {
  // @@protoc_insertion_point(field_list:lidar_algorithm.common.proto.AABB3Ds.aabb3ds)
  return aabb3ds_;
}

// -------------------------------------------------------------------

// OBB3D

// .lidar_algorithm.common.proto.Point3D min_point = 1;
inline bool OBB3D::has_min_point() const {
  return this != internal_default_instance() && min_point_ != nullptr;
}
inline void OBB3D::clear_min_point() {
  if (GetArenaNoVirtual() == nullptr && min_point_ != nullptr) {
    delete min_point_;
  }
  min_point_ = nullptr;
}
inline const ::lidar_algorithm::common::proto::Point3D& OBB3D::min_point() const {
  const ::lidar_algorithm::common::proto::Point3D* p = min_point_;
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.OBB3D.min_point)
  return p != nullptr ? *p : *reinterpret_cast<const ::lidar_algorithm::common::proto::Point3D*>(
      &::lidar_algorithm::common::proto::_Point3D_default_instance_);
}
inline ::lidar_algorithm::common::proto::Point3D* OBB3D::release_min_point() {
  // @@protoc_insertion_point(field_release:lidar_algorithm.common.proto.OBB3D.min_point)
  
  ::lidar_algorithm::common::proto::Point3D* temp = min_point_;
  min_point_ = nullptr;
  return temp;
}
inline ::lidar_algorithm::common::proto::Point3D* OBB3D::mutable_min_point() {
  
  if (min_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::lidar_algorithm::common::proto::Point3D>(GetArenaNoVirtual());
    min_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:lidar_algorithm.common.proto.OBB3D.min_point)
  return min_point_;
}
inline void OBB3D::set_allocated_min_point(::lidar_algorithm::common::proto::Point3D* min_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete min_point_;
  }
  if (min_point) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      min_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, min_point, submessage_arena);
    }
    
  } else {
    
  }
  min_point_ = min_point;
  // @@protoc_insertion_point(field_set_allocated:lidar_algorithm.common.proto.OBB3D.min_point)
}

// .lidar_algorithm.common.proto.Point3D max_point = 2;
inline bool OBB3D::has_max_point() const {
  return this != internal_default_instance() && max_point_ != nullptr;
}
inline void OBB3D::clear_max_point() {
  if (GetArenaNoVirtual() == nullptr && max_point_ != nullptr) {
    delete max_point_;
  }
  max_point_ = nullptr;
}
inline const ::lidar_algorithm::common::proto::Point3D& OBB3D::max_point() const {
  const ::lidar_algorithm::common::proto::Point3D* p = max_point_;
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.OBB3D.max_point)
  return p != nullptr ? *p : *reinterpret_cast<const ::lidar_algorithm::common::proto::Point3D*>(
      &::lidar_algorithm::common::proto::_Point3D_default_instance_);
}
inline ::lidar_algorithm::common::proto::Point3D* OBB3D::release_max_point() {
  // @@protoc_insertion_point(field_release:lidar_algorithm.common.proto.OBB3D.max_point)
  
  ::lidar_algorithm::common::proto::Point3D* temp = max_point_;
  max_point_ = nullptr;
  return temp;
}
inline ::lidar_algorithm::common::proto::Point3D* OBB3D::mutable_max_point() {
  
  if (max_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::lidar_algorithm::common::proto::Point3D>(GetArenaNoVirtual());
    max_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:lidar_algorithm.common.proto.OBB3D.max_point)
  return max_point_;
}
inline void OBB3D::set_allocated_max_point(::lidar_algorithm::common::proto::Point3D* max_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete max_point_;
  }
  if (max_point) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      max_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, max_point, submessage_arena);
    }
    
  } else {
    
  }
  max_point_ = max_point;
  // @@protoc_insertion_point(field_set_allocated:lidar_algorithm.common.proto.OBB3D.max_point)
}

// .lidar_algorithm.common.proto.Point3D position = 3;
inline bool OBB3D::has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline void OBB3D::clear_position() {
  if (GetArenaNoVirtual() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::lidar_algorithm::common::proto::Point3D& OBB3D::position() const {
  const ::lidar_algorithm::common::proto::Point3D* p = position_;
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.OBB3D.position)
  return p != nullptr ? *p : *reinterpret_cast<const ::lidar_algorithm::common::proto::Point3D*>(
      &::lidar_algorithm::common::proto::_Point3D_default_instance_);
}
inline ::lidar_algorithm::common::proto::Point3D* OBB3D::release_position() {
  // @@protoc_insertion_point(field_release:lidar_algorithm.common.proto.OBB3D.position)
  
  ::lidar_algorithm::common::proto::Point3D* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::lidar_algorithm::common::proto::Point3D* OBB3D::mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::lidar_algorithm::common::proto::Point3D>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:lidar_algorithm.common.proto.OBB3D.position)
  return position_;
}
inline void OBB3D::set_allocated_position(::lidar_algorithm::common::proto::Point3D* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:lidar_algorithm.common.proto.OBB3D.position)
}

// .lidar_algorithm.common.proto.Quaternion quat = 4;
inline bool OBB3D::has_quat() const {
  return this != internal_default_instance() && quat_ != nullptr;
}
inline void OBB3D::clear_quat() {
  if (GetArenaNoVirtual() == nullptr && quat_ != nullptr) {
    delete quat_;
  }
  quat_ = nullptr;
}
inline const ::lidar_algorithm::common::proto::Quaternion& OBB3D::quat() const {
  const ::lidar_algorithm::common::proto::Quaternion* p = quat_;
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.OBB3D.quat)
  return p != nullptr ? *p : *reinterpret_cast<const ::lidar_algorithm::common::proto::Quaternion*>(
      &::lidar_algorithm::common::proto::_Quaternion_default_instance_);
}
inline ::lidar_algorithm::common::proto::Quaternion* OBB3D::release_quat() {
  // @@protoc_insertion_point(field_release:lidar_algorithm.common.proto.OBB3D.quat)
  
  ::lidar_algorithm::common::proto::Quaternion* temp = quat_;
  quat_ = nullptr;
  return temp;
}
inline ::lidar_algorithm::common::proto::Quaternion* OBB3D::mutable_quat() {
  
  if (quat_ == nullptr) {
    auto* p = CreateMaybeMessage<::lidar_algorithm::common::proto::Quaternion>(GetArenaNoVirtual());
    quat_ = p;
  }
  // @@protoc_insertion_point(field_mutable:lidar_algorithm.common.proto.OBB3D.quat)
  return quat_;
}
inline void OBB3D::set_allocated_quat(::lidar_algorithm::common::proto::Quaternion* quat) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete quat_;
  }
  if (quat) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      quat = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, quat, submessage_arena);
    }
    
  } else {
    
  }
  quat_ = quat;
  // @@protoc_insertion_point(field_set_allocated:lidar_algorithm.common.proto.OBB3D.quat)
}

// -------------------------------------------------------------------

// OBB3Ds

// repeated .lidar_algorithm.common.proto.OBB3D obb3ds = 1;
inline int OBB3Ds::obb3ds_size() const {
  return obb3ds_.size();
}
inline void OBB3Ds::clear_obb3ds() {
  obb3ds_.Clear();
}
inline ::lidar_algorithm::common::proto::OBB3D* OBB3Ds::mutable_obb3ds(int index) {
  // @@protoc_insertion_point(field_mutable:lidar_algorithm.common.proto.OBB3Ds.obb3ds)
  return obb3ds_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::OBB3D >*
OBB3Ds::mutable_obb3ds() {
  // @@protoc_insertion_point(field_mutable_list:lidar_algorithm.common.proto.OBB3Ds.obb3ds)
  return &obb3ds_;
}
inline const ::lidar_algorithm::common::proto::OBB3D& OBB3Ds::obb3ds(int index) const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.OBB3Ds.obb3ds)
  return obb3ds_.Get(index);
}
inline ::lidar_algorithm::common::proto::OBB3D* OBB3Ds::add_obb3ds() {
  // @@protoc_insertion_point(field_add:lidar_algorithm.common.proto.OBB3Ds.obb3ds)
  return obb3ds_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::OBB3D >&
OBB3Ds::obb3ds() const {
  // @@protoc_insertion_point(field_list:lidar_algorithm.common.proto.OBB3Ds.obb3ds)
  return obb3ds_;
}

// -------------------------------------------------------------------

// Cluster

// repeated .lidar_algorithm.common.proto.Point3D points = 1;
inline int Cluster::points_size() const {
  return points_.size();
}
inline void Cluster::clear_points() {
  points_.Clear();
}
inline ::lidar_algorithm::common::proto::Point3D* Cluster::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:lidar_algorithm.common.proto.Cluster.points)
  return points_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point3D >*
Cluster::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:lidar_algorithm.common.proto.Cluster.points)
  return &points_;
}
inline const ::lidar_algorithm::common::proto::Point3D& Cluster::points(int index) const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.Cluster.points)
  return points_.Get(index);
}
inline ::lidar_algorithm::common::proto::Point3D* Cluster::add_points() {
  // @@protoc_insertion_point(field_add:lidar_algorithm.common.proto.Cluster.points)
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Point3D >&
Cluster::points() const {
  // @@protoc_insertion_point(field_list:lidar_algorithm.common.proto.Cluster.points)
  return points_;
}

// -------------------------------------------------------------------

// Clusters

// repeated .lidar_algorithm.common.proto.Cluster clusters = 1;
inline int Clusters::clusters_size() const {
  return clusters_.size();
}
inline void Clusters::clear_clusters() {
  clusters_.Clear();
}
inline ::lidar_algorithm::common::proto::Cluster* Clusters::mutable_clusters(int index) {
  // @@protoc_insertion_point(field_mutable:lidar_algorithm.common.proto.Clusters.clusters)
  return clusters_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Cluster >*
Clusters::mutable_clusters() {
  // @@protoc_insertion_point(field_mutable_list:lidar_algorithm.common.proto.Clusters.clusters)
  return &clusters_;
}
inline const ::lidar_algorithm::common::proto::Cluster& Clusters::clusters(int index) const {
  // @@protoc_insertion_point(field_get:lidar_algorithm.common.proto.Clusters.clusters)
  return clusters_.Get(index);
}
inline ::lidar_algorithm::common::proto::Cluster* Clusters::add_clusters() {
  // @@protoc_insertion_point(field_add:lidar_algorithm.common.proto.Clusters.clusters)
  return clusters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lidar_algorithm::common::proto::Cluster >&
Clusters::clusters() const {
  // @@protoc_insertion_point(field_list:lidar_algorithm.common.proto.Clusters.clusters)
  return clusters_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace common
}  // namespace lidar_algorithm

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_geometry_2eproto
