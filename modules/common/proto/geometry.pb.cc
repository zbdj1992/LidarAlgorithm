// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: geometry.proto

#include "geometry.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

extern PROTOBUF_INTERNAL_EXPORT_geometry_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Point2D_geometry_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_geometry_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Point3D_geometry_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_geometry_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_PointXYZIL_geometry_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_geometry_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Quaternion_geometry_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_geometry_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_AABB3D_geometry_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_geometry_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_Cluster_geometry_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_geometry_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_OBB3D_geometry_2eproto;
namespace lidar_algorithm {
namespace common {
namespace proto {
class Point2DDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Point2D> _instance;
} _Point2D_default_instance_;
class Point3DDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Point3D> _instance;
} _Point3D_default_instance_;
class PolygonDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Polygon> _instance;
} _Polygon_default_instance_;
class PointPairDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<PointPair> _instance;
} _PointPair_default_instance_;
class PointTripleDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<PointTriple> _instance;
} _PointTriple_default_instance_;
class Box2DDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Box2D> _instance;
} _Box2D_default_instance_;
class Box3DDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Box3D> _instance;
} _Box3D_default_instance_;
class PathLinesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<PathLines> _instance;
} _PathLines_default_instance_;
class ObsOccuPathPctDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ObsOccuPathPct> _instance;
} _ObsOccuPathPct_default_instance_;
class PointXYZILDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<PointXYZIL> _instance;
} _PointXYZIL_default_instance_;
class PointCloudDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<PointCloud> _instance;
} _PointCloud_default_instance_;
class QuaternionDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Quaternion> _instance;
} _Quaternion_default_instance_;
class AABB3DDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<AABB3D> _instance;
} _AABB3D_default_instance_;
class AABB3DsDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<AABB3Ds> _instance;
} _AABB3Ds_default_instance_;
class OBB3DDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<OBB3D> _instance;
} _OBB3D_default_instance_;
class OBB3DsDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<OBB3Ds> _instance;
} _OBB3Ds_default_instance_;
class ClusterDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Cluster> _instance;
} _Cluster_default_instance_;
class ClustersDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Clusters> _instance;
} _Clusters_default_instance_;
}  // namespace proto
}  // namespace common
}  // namespace lidar_algorithm
static void InitDefaultsPoint2D_geometry_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::lidar_algorithm::common::proto::_Point2D_default_instance_;
    new (ptr) ::lidar_algorithm::common::proto::Point2D();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::lidar_algorithm::common::proto::Point2D::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Point2D_geometry_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsPoint2D_geometry_2eproto}, {}};

static void InitDefaultsPoint3D_geometry_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::lidar_algorithm::common::proto::_Point3D_default_instance_;
    new (ptr) ::lidar_algorithm::common::proto::Point3D();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::lidar_algorithm::common::proto::Point3D::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Point3D_geometry_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsPoint3D_geometry_2eproto}, {}};

static void InitDefaultsPolygon_geometry_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::lidar_algorithm::common::proto::_Polygon_default_instance_;
    new (ptr) ::lidar_algorithm::common::proto::Polygon();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::lidar_algorithm::common::proto::Polygon::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_Polygon_geometry_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsPolygon_geometry_2eproto}, {
      &scc_info_Point3D_geometry_2eproto.base,}};

static void InitDefaultsPointPair_geometry_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::lidar_algorithm::common::proto::_PointPair_default_instance_;
    new (ptr) ::lidar_algorithm::common::proto::PointPair();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::lidar_algorithm::common::proto::PointPair::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_PointPair_geometry_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsPointPair_geometry_2eproto}, {
      &scc_info_Point2D_geometry_2eproto.base,}};

static void InitDefaultsPointTriple_geometry_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::lidar_algorithm::common::proto::_PointTriple_default_instance_;
    new (ptr) ::lidar_algorithm::common::proto::PointTriple();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::lidar_algorithm::common::proto::PointTriple::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_PointTriple_geometry_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsPointTriple_geometry_2eproto}, {
      &scc_info_Point2D_geometry_2eproto.base,}};

static void InitDefaultsBox2D_geometry_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::lidar_algorithm::common::proto::_Box2D_default_instance_;
    new (ptr) ::lidar_algorithm::common::proto::Box2D();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::lidar_algorithm::common::proto::Box2D::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Box2D_geometry_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsBox2D_geometry_2eproto}, {}};

static void InitDefaultsBox3D_geometry_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::lidar_algorithm::common::proto::_Box3D_default_instance_;
    new (ptr) ::lidar_algorithm::common::proto::Box3D();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::lidar_algorithm::common::proto::Box3D::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Box3D_geometry_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsBox3D_geometry_2eproto}, {}};

static void InitDefaultsPathLines_geometry_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::lidar_algorithm::common::proto::_PathLines_default_instance_;
    new (ptr) ::lidar_algorithm::common::proto::PathLines();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::lidar_algorithm::common::proto::PathLines::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_PathLines_geometry_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsPathLines_geometry_2eproto}, {
      &scc_info_Point2D_geometry_2eproto.base,}};

static void InitDefaultsObsOccuPathPct_geometry_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::lidar_algorithm::common::proto::_ObsOccuPathPct_default_instance_;
    new (ptr) ::lidar_algorithm::common::proto::ObsOccuPathPct();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::lidar_algorithm::common::proto::ObsOccuPathPct::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_ObsOccuPathPct_geometry_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsObsOccuPathPct_geometry_2eproto}, {}};

static void InitDefaultsPointXYZIL_geometry_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::lidar_algorithm::common::proto::_PointXYZIL_default_instance_;
    new (ptr) ::lidar_algorithm::common::proto::PointXYZIL();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::lidar_algorithm::common::proto::PointXYZIL::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_PointXYZIL_geometry_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsPointXYZIL_geometry_2eproto}, {}};

static void InitDefaultsPointCloud_geometry_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::lidar_algorithm::common::proto::_PointCloud_default_instance_;
    new (ptr) ::lidar_algorithm::common::proto::PointCloud();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::lidar_algorithm::common::proto::PointCloud::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_PointCloud_geometry_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsPointCloud_geometry_2eproto}, {
      &scc_info_PointXYZIL_geometry_2eproto.base,}};

static void InitDefaultsQuaternion_geometry_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::lidar_algorithm::common::proto::_Quaternion_default_instance_;
    new (ptr) ::lidar_algorithm::common::proto::Quaternion();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::lidar_algorithm::common::proto::Quaternion::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Quaternion_geometry_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsQuaternion_geometry_2eproto}, {}};

static void InitDefaultsAABB3D_geometry_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::lidar_algorithm::common::proto::_AABB3D_default_instance_;
    new (ptr) ::lidar_algorithm::common::proto::AABB3D();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::lidar_algorithm::common::proto::AABB3D::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_AABB3D_geometry_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsAABB3D_geometry_2eproto}, {
      &scc_info_Point3D_geometry_2eproto.base,}};

static void InitDefaultsAABB3Ds_geometry_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::lidar_algorithm::common::proto::_AABB3Ds_default_instance_;
    new (ptr) ::lidar_algorithm::common::proto::AABB3Ds();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::lidar_algorithm::common::proto::AABB3Ds::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_AABB3Ds_geometry_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsAABB3Ds_geometry_2eproto}, {
      &scc_info_AABB3D_geometry_2eproto.base,}};

static void InitDefaultsOBB3D_geometry_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::lidar_algorithm::common::proto::_OBB3D_default_instance_;
    new (ptr) ::lidar_algorithm::common::proto::OBB3D();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::lidar_algorithm::common::proto::OBB3D::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_OBB3D_geometry_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsOBB3D_geometry_2eproto}, {
      &scc_info_Point3D_geometry_2eproto.base,
      &scc_info_Quaternion_geometry_2eproto.base,}};

static void InitDefaultsOBB3Ds_geometry_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::lidar_algorithm::common::proto::_OBB3Ds_default_instance_;
    new (ptr) ::lidar_algorithm::common::proto::OBB3Ds();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::lidar_algorithm::common::proto::OBB3Ds::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_OBB3Ds_geometry_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsOBB3Ds_geometry_2eproto}, {
      &scc_info_OBB3D_geometry_2eproto.base,}};

static void InitDefaultsCluster_geometry_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::lidar_algorithm::common::proto::_Cluster_default_instance_;
    new (ptr) ::lidar_algorithm::common::proto::Cluster();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::lidar_algorithm::common::proto::Cluster::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_Cluster_geometry_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCluster_geometry_2eproto}, {
      &scc_info_Point3D_geometry_2eproto.base,}};

static void InitDefaultsClusters_geometry_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::lidar_algorithm::common::proto::_Clusters_default_instance_;
    new (ptr) ::lidar_algorithm::common::proto::Clusters();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::lidar_algorithm::common::proto::Clusters::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_Clusters_geometry_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsClusters_geometry_2eproto}, {
      &scc_info_Cluster_geometry_2eproto.base,}};

void InitDefaults_geometry_2eproto() {
  ::google::protobuf::internal::InitSCC(&scc_info_Point2D_geometry_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Point3D_geometry_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Polygon_geometry_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_PointPair_geometry_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_PointTriple_geometry_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Box2D_geometry_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Box3D_geometry_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_PathLines_geometry_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ObsOccuPathPct_geometry_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_PointXYZIL_geometry_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_PointCloud_geometry_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Quaternion_geometry_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_AABB3D_geometry_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_AABB3Ds_geometry_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_OBB3D_geometry_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_OBB3Ds_geometry_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Cluster_geometry_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Clusters_geometry_2eproto.base);
}

::google::protobuf::Metadata file_level_metadata_geometry_2eproto[18];
constexpr ::google::protobuf::EnumDescriptor const** file_level_enum_descriptors_geometry_2eproto = nullptr;
constexpr ::google::protobuf::ServiceDescriptor const** file_level_service_descriptors_geometry_2eproto = nullptr;

const ::google::protobuf::uint32 TableStruct_geometry_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Point2D, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Point2D, x_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Point2D, y_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Point3D, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Point3D, x_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Point3D, y_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Point3D, z_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Polygon, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Polygon, points_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::PointPair, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::PointPair, left_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::PointPair, right_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::PointTriple, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::PointTriple, left_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::PointTriple, middle_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::PointTriple, right_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Box2D, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Box2D, x_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Box2D, y_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Box2D, height_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Box2D, width_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Box3D, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Box3D, x_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Box3D, y_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Box3D, z_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Box3D, length_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Box3D, width_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Box3D, height_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::PathLines, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::PathLines, left_line_2_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::PathLines, left_line_1_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::PathLines, line_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::PathLines, right_line_1_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::PathLines, right_line_2_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::ObsOccuPathPct, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::ObsOccuPathPct, left_pct_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::ObsOccuPathPct, right_pct_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::PointXYZIL, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::PointXYZIL, x_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::PointXYZIL, y_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::PointXYZIL, z_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::PointXYZIL, intensity_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::PointXYZIL, label_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::PointCloud, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::PointCloud, timestamp_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::PointCloud, points_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Quaternion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Quaternion, w_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Quaternion, x_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Quaternion, y_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Quaternion, z_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::AABB3D, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::AABB3D, min_point_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::AABB3D, max_point_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::AABB3Ds, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::AABB3Ds, aabb3ds_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::OBB3D, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::OBB3D, min_point_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::OBB3D, max_point_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::OBB3D, position_),
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::OBB3D, quat_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::OBB3Ds, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::OBB3Ds, obb3ds_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Cluster, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Cluster, points_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Clusters, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::lidar_algorithm::common::proto::Clusters, clusters_),
};
static const ::google::protobuf::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, sizeof(::lidar_algorithm::common::proto::Point2D)},
  { 7, -1, sizeof(::lidar_algorithm::common::proto::Point3D)},
  { 15, -1, sizeof(::lidar_algorithm::common::proto::Polygon)},
  { 21, -1, sizeof(::lidar_algorithm::common::proto::PointPair)},
  { 28, -1, sizeof(::lidar_algorithm::common::proto::PointTriple)},
  { 36, -1, sizeof(::lidar_algorithm::common::proto::Box2D)},
  { 45, -1, sizeof(::lidar_algorithm::common::proto::Box3D)},
  { 56, -1, sizeof(::lidar_algorithm::common::proto::PathLines)},
  { 66, -1, sizeof(::lidar_algorithm::common::proto::ObsOccuPathPct)},
  { 73, -1, sizeof(::lidar_algorithm::common::proto::PointXYZIL)},
  { 83, -1, sizeof(::lidar_algorithm::common::proto::PointCloud)},
  { 90, -1, sizeof(::lidar_algorithm::common::proto::Quaternion)},
  { 99, -1, sizeof(::lidar_algorithm::common::proto::AABB3D)},
  { 106, -1, sizeof(::lidar_algorithm::common::proto::AABB3Ds)},
  { 112, -1, sizeof(::lidar_algorithm::common::proto::OBB3D)},
  { 121, -1, sizeof(::lidar_algorithm::common::proto::OBB3Ds)},
  { 127, -1, sizeof(::lidar_algorithm::common::proto::Cluster)},
  { 133, -1, sizeof(::lidar_algorithm::common::proto::Clusters)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::lidar_algorithm::common::proto::_Point2D_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::lidar_algorithm::common::proto::_Point3D_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::lidar_algorithm::common::proto::_Polygon_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::lidar_algorithm::common::proto::_PointPair_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::lidar_algorithm::common::proto::_PointTriple_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::lidar_algorithm::common::proto::_Box2D_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::lidar_algorithm::common::proto::_Box3D_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::lidar_algorithm::common::proto::_PathLines_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::lidar_algorithm::common::proto::_ObsOccuPathPct_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::lidar_algorithm::common::proto::_PointXYZIL_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::lidar_algorithm::common::proto::_PointCloud_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::lidar_algorithm::common::proto::_Quaternion_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::lidar_algorithm::common::proto::_AABB3D_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::lidar_algorithm::common::proto::_AABB3Ds_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::lidar_algorithm::common::proto::_OBB3D_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::lidar_algorithm::common::proto::_OBB3Ds_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::lidar_algorithm::common::proto::_Cluster_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::lidar_algorithm::common::proto::_Clusters_default_instance_),
};

::google::protobuf::internal::AssignDescriptorsTable assign_descriptors_table_geometry_2eproto = {
  {}, AddDescriptors_geometry_2eproto, "geometry.proto", schemas,
  file_default_instances, TableStruct_geometry_2eproto::offsets,
  file_level_metadata_geometry_2eproto, 18, file_level_enum_descriptors_geometry_2eproto, file_level_service_descriptors_geometry_2eproto,
};

const char descriptor_table_protodef_geometry_2eproto[] =
  "\n\016geometry.proto\022\034lidar_algorithm.common"
  ".proto\"\037\n\007Point2D\022\t\n\001x\030\001 \001(\001\022\t\n\001y\030\002 \001(\001\""
  "*\n\007Point3D\022\t\n\001x\030\001 \001(\001\022\t\n\001y\030\002 \001(\001\022\t\n\001z\030\003 "
  "\001(\001\"@\n\007Polygon\0225\n\006points\030\001 \003(\0132%.lidar_a"
  "lgorithm.common.proto.Point3D\"v\n\tPointPa"
  "ir\0223\n\004left\030\001 \001(\0132%.lidar_algorithm.commo"
  "n.proto.Point2D\0224\n\005right\030\002 \001(\0132%.lidar_a"
  "lgorithm.common.proto.Point2D\"\257\001\n\013PointT"
  "riple\0223\n\004left\030\001 \001(\0132%.lidar_algorithm.co"
  "mmon.proto.Point2D\0225\n\006middle\030\002 \001(\0132%.lid"
  "ar_algorithm.common.proto.Point2D\0224\n\005rig"
  "ht\030\003 \001(\0132%.lidar_algorithm.common.proto."
  "Point2D\"<\n\005Box2D\022\t\n\001x\030\001 \001(\001\022\t\n\001y\030\002 \001(\001\022\016"
  "\n\006height\030\003 \001(\001\022\r\n\005width\030\004 \001(\001\"W\n\005Box3D\022\t"
  "\n\001x\030\001 \001(\001\022\t\n\001y\030\002 \001(\001\022\t\n\001z\030\003 \001(\001\022\016\n\006lengt"
  "h\030\004 \001(\001\022\r\n\005width\030\005 \001(\001\022\016\n\006height\030\006 \001(\001\"\262"
  "\002\n\tPathLines\022:\n\013left_line_2\030\001 \003(\0132%.lida"
  "r_algorithm.common.proto.Point2D\022:\n\013left"
  "_line_1\030\002 \003(\0132%.lidar_algorithm.common.p"
  "roto.Point2D\0223\n\004line\030\003 \003(\0132%.lidar_algor"
  "ithm.common.proto.Point2D\022;\n\014right_line_"
  "1\030\004 \003(\0132%.lidar_algorithm.common.proto.P"
  "oint2D\022;\n\014right_line_2\030\005 \003(\0132%.lidar_alg"
  "orithm.common.proto.Point2D\"5\n\016ObsOccuPa"
  "thPct\022\020\n\010left_pct\030\001 \001(\005\022\021\n\tright_pct\030\002 \001"
  "(\005\"O\n\nPointXYZIL\022\t\n\001x\030\001 \001(\001\022\t\n\001y\030\002 \001(\001\022\t"
  "\n\001z\030\003 \001(\001\022\021\n\tintensity\030\004 \001(\001\022\r\n\005label\030\005 "
  "\001(\r\"Y\n\nPointCloud\022\021\n\ttimestamp\030\001 \001(\003\0228\n\006"
  "points\030\002 \003(\0132(.lidar_algorithm.common.pr"
  "oto.PointXYZIL\"8\n\nQuaternion\022\t\n\001w\030\001 \001(\001\022"
  "\t\n\001x\030\002 \001(\001\022\t\n\001y\030\003 \001(\001\022\t\n\001z\030\004 \001(\001\"|\n\006AABB"
  "3D\0228\n\tmin_point\030\001 \001(\0132%.lidar_algorithm."
  "common.proto.Point3D\0228\n\tmax_point\030\002 \001(\0132"
  "%.lidar_algorithm.common.proto.Point3D\"@"
  "\n\007AABB3Ds\0225\n\007aabb3ds\030\001 \003(\0132$.lidar_algor"
  "ithm.common.proto.AABB3D\"\354\001\n\005OBB3D\0228\n\tmi"
  "n_point\030\001 \001(\0132%.lidar_algorithm.common.p"
  "roto.Point3D\0228\n\tmax_point\030\002 \001(\0132%.lidar_"
  "algorithm.common.proto.Point3D\0227\n\010positi"
  "on\030\003 \001(\0132%.lidar_algorithm.common.proto."
  "Point3D\0226\n\004quat\030\004 \001(\0132(.lidar_algorithm."
  "common.proto.Quaternion\"=\n\006OBB3Ds\0223\n\006obb"
  "3ds\030\001 \003(\0132#.lidar_algorithm.common.proto"
  ".OBB3D\"@\n\007Cluster\0225\n\006points\030\001 \003(\0132%.lida"
  "r_algorithm.common.proto.Point3D\"C\n\010Clus"
  "ters\0227\n\010clusters\030\001 \003(\0132%.lidar_algorithm"
  ".common.proto.Clusterb\006proto3"
  ;
::google::protobuf::internal::DescriptorTable descriptor_table_geometry_2eproto = {
  false, InitDefaults_geometry_2eproto, 
  descriptor_table_protodef_geometry_2eproto,
  "geometry.proto", &assign_descriptors_table_geometry_2eproto, 1869,
};

void AddDescriptors_geometry_2eproto() {
  static constexpr ::google::protobuf::internal::InitFunc deps[1] =
  {
  };
 ::google::protobuf::internal::AddDescriptors(&descriptor_table_geometry_2eproto, deps, 0);
}

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_geometry_2eproto = []() { AddDescriptors_geometry_2eproto(); return true; }();
namespace lidar_algorithm {
namespace common {
namespace proto {

// ===================================================================

void Point2D::InitAsDefaultInstance() {
}
class Point2D::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Point2D::kXFieldNumber;
const int Point2D::kYFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Point2D::Point2D()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:lidar_algorithm.common.proto.Point2D)
}
Point2D::Point2D(const Point2D& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&x_)) + sizeof(y_));
  // @@protoc_insertion_point(copy_constructor:lidar_algorithm.common.proto.Point2D)
}

void Point2D::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&y_) -
      reinterpret_cast<char*>(&x_)) + sizeof(y_));
}

Point2D::~Point2D() {
  // @@protoc_insertion_point(destructor:lidar_algorithm.common.proto.Point2D)
  SharedDtor();
}

void Point2D::SharedDtor() {
}

void Point2D::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Point2D& Point2D::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Point2D_geometry_2eproto.base);
  return *internal_default_instance();
}


void Point2D::Clear() {
// @@protoc_insertion_point(message_clear_start:lidar_algorithm.common.proto.Point2D)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&y_) -
      reinterpret_cast<char*>(&x_)) + sizeof(y_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Point2D::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Point2D*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // double x = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        msg->set_x(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // double y = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        msg->set_y(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Point2D::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:lidar_algorithm.common.proto.Point2D)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // double x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:lidar_algorithm.common.proto.Point2D)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:lidar_algorithm.common.proto.Point2D)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Point2D::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:lidar_algorithm.common.proto.Point2D)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double x = 1;
  if (this->x() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // double y = 2;
  if (this->y() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:lidar_algorithm.common.proto.Point2D)
}

::google::protobuf::uint8* Point2D::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:lidar_algorithm.common.proto.Point2D)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double x = 1;
  if (this->x() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // double y = 2;
  if (this->y() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lidar_algorithm.common.proto.Point2D)
  return target;
}

size_t Point2D::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lidar_algorithm.common.proto.Point2D)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double x = 1;
  if (this->x() != 0) {
    total_size += 1 + 8;
  }

  // double y = 2;
  if (this->y() != 0) {
    total_size += 1 + 8;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Point2D::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:lidar_algorithm.common.proto.Point2D)
  GOOGLE_DCHECK_NE(&from, this);
  const Point2D* source =
      ::google::protobuf::DynamicCastToGenerated<Point2D>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:lidar_algorithm.common.proto.Point2D)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:lidar_algorithm.common.proto.Point2D)
    MergeFrom(*source);
  }
}

void Point2D::MergeFrom(const Point2D& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:lidar_algorithm.common.proto.Point2D)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.x() != 0) {
    set_x(from.x());
  }
  if (from.y() != 0) {
    set_y(from.y());
  }
}

void Point2D::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:lidar_algorithm.common.proto.Point2D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Point2D::CopyFrom(const Point2D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lidar_algorithm.common.proto.Point2D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Point2D::IsInitialized() const {
  return true;
}

void Point2D::Swap(Point2D* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Point2D::InternalSwap(Point2D* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(x_, other->x_);
  swap(y_, other->y_);
}

::google::protobuf::Metadata Point2D::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_geometry_2eproto);
  return ::file_level_metadata_geometry_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Point3D::InitAsDefaultInstance() {
}
class Point3D::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Point3D::kXFieldNumber;
const int Point3D::kYFieldNumber;
const int Point3D::kZFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Point3D::Point3D()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:lidar_algorithm.common.proto.Point3D)
}
Point3D::Point3D(const Point3D& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
  // @@protoc_insertion_point(copy_constructor:lidar_algorithm.common.proto.Point3D)
}

void Point3D::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&x_)) + sizeof(z_));
}

Point3D::~Point3D() {
  // @@protoc_insertion_point(destructor:lidar_algorithm.common.proto.Point3D)
  SharedDtor();
}

void Point3D::SharedDtor() {
}

void Point3D::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Point3D& Point3D::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Point3D_geometry_2eproto.base);
  return *internal_default_instance();
}


void Point3D::Clear() {
// @@protoc_insertion_point(message_clear_start:lidar_algorithm.common.proto.Point3D)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&x_)) + sizeof(z_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Point3D::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Point3D*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // double x = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        msg->set_x(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // double y = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        msg->set_y(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // double z = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        msg->set_z(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Point3D::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:lidar_algorithm.common.proto.Point3D)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // double x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double z = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:lidar_algorithm.common.proto.Point3D)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:lidar_algorithm.common.proto.Point3D)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Point3D::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:lidar_algorithm.common.proto.Point3D)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double x = 1;
  if (this->x() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // double y = 2;
  if (this->y() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // double z = 3;
  if (this->z() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:lidar_algorithm.common.proto.Point3D)
}

::google::protobuf::uint8* Point3D::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:lidar_algorithm.common.proto.Point3D)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double x = 1;
  if (this->x() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // double y = 2;
  if (this->y() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // double z = 3;
  if (this->z() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->z(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lidar_algorithm.common.proto.Point3D)
  return target;
}

size_t Point3D::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lidar_algorithm.common.proto.Point3D)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double x = 1;
  if (this->x() != 0) {
    total_size += 1 + 8;
  }

  // double y = 2;
  if (this->y() != 0) {
    total_size += 1 + 8;
  }

  // double z = 3;
  if (this->z() != 0) {
    total_size += 1 + 8;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Point3D::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:lidar_algorithm.common.proto.Point3D)
  GOOGLE_DCHECK_NE(&from, this);
  const Point3D* source =
      ::google::protobuf::DynamicCastToGenerated<Point3D>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:lidar_algorithm.common.proto.Point3D)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:lidar_algorithm.common.proto.Point3D)
    MergeFrom(*source);
  }
}

void Point3D::MergeFrom(const Point3D& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:lidar_algorithm.common.proto.Point3D)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.x() != 0) {
    set_x(from.x());
  }
  if (from.y() != 0) {
    set_y(from.y());
  }
  if (from.z() != 0) {
    set_z(from.z());
  }
}

void Point3D::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:lidar_algorithm.common.proto.Point3D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Point3D::CopyFrom(const Point3D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lidar_algorithm.common.proto.Point3D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Point3D::IsInitialized() const {
  return true;
}

void Point3D::Swap(Point3D* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Point3D::InternalSwap(Point3D* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(z_, other->z_);
}

::google::protobuf::Metadata Point3D::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_geometry_2eproto);
  return ::file_level_metadata_geometry_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Polygon::InitAsDefaultInstance() {
}
class Polygon::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Polygon::kPointsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Polygon::Polygon()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:lidar_algorithm.common.proto.Polygon)
}
Polygon::Polygon(const Polygon& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      points_(from.points_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:lidar_algorithm.common.proto.Polygon)
}

void Polygon::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Polygon_geometry_2eproto.base);
}

Polygon::~Polygon() {
  // @@protoc_insertion_point(destructor:lidar_algorithm.common.proto.Polygon)
  SharedDtor();
}

void Polygon::SharedDtor() {
}

void Polygon::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Polygon& Polygon::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Polygon_geometry_2eproto.base);
  return *internal_default_instance();
}


void Polygon::Clear() {
// @@protoc_insertion_point(message_clear_start:lidar_algorithm.common.proto.Polygon)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  points_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Polygon::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Polygon*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated .lidar_algorithm.common.proto.Point3D points = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::lidar_algorithm::common::proto::Point3D::_InternalParse;
          object = msg->add_points();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Polygon::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:lidar_algorithm.common.proto.Polygon)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .lidar_algorithm.common.proto.Point3D points = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_points()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:lidar_algorithm.common.proto.Polygon)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:lidar_algorithm.common.proto.Polygon)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Polygon::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:lidar_algorithm.common.proto.Polygon)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .lidar_algorithm.common.proto.Point3D points = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->points_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->points(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:lidar_algorithm.common.proto.Polygon)
}

::google::protobuf::uint8* Polygon::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:lidar_algorithm.common.proto.Polygon)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .lidar_algorithm.common.proto.Point3D points = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->points_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->points(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lidar_algorithm.common.proto.Polygon)
  return target;
}

size_t Polygon::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lidar_algorithm.common.proto.Polygon)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .lidar_algorithm.common.proto.Point3D points = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->points_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->points(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Polygon::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:lidar_algorithm.common.proto.Polygon)
  GOOGLE_DCHECK_NE(&from, this);
  const Polygon* source =
      ::google::protobuf::DynamicCastToGenerated<Polygon>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:lidar_algorithm.common.proto.Polygon)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:lidar_algorithm.common.proto.Polygon)
    MergeFrom(*source);
  }
}

void Polygon::MergeFrom(const Polygon& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:lidar_algorithm.common.proto.Polygon)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  points_.MergeFrom(from.points_);
}

void Polygon::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:lidar_algorithm.common.proto.Polygon)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Polygon::CopyFrom(const Polygon& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lidar_algorithm.common.proto.Polygon)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Polygon::IsInitialized() const {
  return true;
}

void Polygon::Swap(Polygon* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Polygon::InternalSwap(Polygon* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  CastToBase(&points_)->InternalSwap(CastToBase(&other->points_));
}

::google::protobuf::Metadata Polygon::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_geometry_2eproto);
  return ::file_level_metadata_geometry_2eproto[kIndexInFileMessages];
}


// ===================================================================

void PointPair::InitAsDefaultInstance() {
  ::lidar_algorithm::common::proto::_PointPair_default_instance_._instance.get_mutable()->left_ = const_cast< ::lidar_algorithm::common::proto::Point2D*>(
      ::lidar_algorithm::common::proto::Point2D::internal_default_instance());
  ::lidar_algorithm::common::proto::_PointPair_default_instance_._instance.get_mutable()->right_ = const_cast< ::lidar_algorithm::common::proto::Point2D*>(
      ::lidar_algorithm::common::proto::Point2D::internal_default_instance());
}
class PointPair::HasBitSetters {
 public:
  static const ::lidar_algorithm::common::proto::Point2D& left(const PointPair* msg);
  static const ::lidar_algorithm::common::proto::Point2D& right(const PointPair* msg);
};

const ::lidar_algorithm::common::proto::Point2D&
PointPair::HasBitSetters::left(const PointPair* msg) {
  return *msg->left_;
}
const ::lidar_algorithm::common::proto::Point2D&
PointPair::HasBitSetters::right(const PointPair* msg) {
  return *msg->right_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PointPair::kLeftFieldNumber;
const int PointPair::kRightFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PointPair::PointPair()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:lidar_algorithm.common.proto.PointPair)
}
PointPair::PointPair(const PointPair& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_left()) {
    left_ = new ::lidar_algorithm::common::proto::Point2D(*from.left_);
  } else {
    left_ = nullptr;
  }
  if (from.has_right()) {
    right_ = new ::lidar_algorithm::common::proto::Point2D(*from.right_);
  } else {
    right_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:lidar_algorithm.common.proto.PointPair)
}

void PointPair::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_PointPair_geometry_2eproto.base);
  ::memset(&left_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&right_) -
      reinterpret_cast<char*>(&left_)) + sizeof(right_));
}

PointPair::~PointPair() {
  // @@protoc_insertion_point(destructor:lidar_algorithm.common.proto.PointPair)
  SharedDtor();
}

void PointPair::SharedDtor() {
  if (this != internal_default_instance()) delete left_;
  if (this != internal_default_instance()) delete right_;
}

void PointPair::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PointPair& PointPair::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_PointPair_geometry_2eproto.base);
  return *internal_default_instance();
}


void PointPair::Clear() {
// @@protoc_insertion_point(message_clear_start:lidar_algorithm.common.proto.PointPair)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == nullptr && left_ != nullptr) {
    delete left_;
  }
  left_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && right_ != nullptr) {
    delete right_;
  }
  right_ = nullptr;
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* PointPair::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<PointPair*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // .lidar_algorithm.common.proto.Point2D left = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::lidar_algorithm::common::proto::Point2D::_InternalParse;
        object = msg->mutable_left();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // .lidar_algorithm.common.proto.Point2D right = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::lidar_algorithm::common::proto::Point2D::_InternalParse;
        object = msg->mutable_right();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool PointPair::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:lidar_algorithm.common.proto.PointPair)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .lidar_algorithm.common.proto.Point2D left = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_left()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .lidar_algorithm.common.proto.Point2D right = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_right()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:lidar_algorithm.common.proto.PointPair)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:lidar_algorithm.common.proto.PointPair)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void PointPair::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:lidar_algorithm.common.proto.PointPair)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .lidar_algorithm.common.proto.Point2D left = 1;
  if (this->has_left()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::left(this), output);
  }

  // .lidar_algorithm.common.proto.Point2D right = 2;
  if (this->has_right()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::right(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:lidar_algorithm.common.proto.PointPair)
}

::google::protobuf::uint8* PointPair::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:lidar_algorithm.common.proto.PointPair)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .lidar_algorithm.common.proto.Point2D left = 1;
  if (this->has_left()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::left(this), target);
  }

  // .lidar_algorithm.common.proto.Point2D right = 2;
  if (this->has_right()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::right(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lidar_algorithm.common.proto.PointPair)
  return target;
}

size_t PointPair::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lidar_algorithm.common.proto.PointPair)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .lidar_algorithm.common.proto.Point2D left = 1;
  if (this->has_left()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *left_);
  }

  // .lidar_algorithm.common.proto.Point2D right = 2;
  if (this->has_right()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *right_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PointPair::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:lidar_algorithm.common.proto.PointPair)
  GOOGLE_DCHECK_NE(&from, this);
  const PointPair* source =
      ::google::protobuf::DynamicCastToGenerated<PointPair>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:lidar_algorithm.common.proto.PointPair)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:lidar_algorithm.common.proto.PointPair)
    MergeFrom(*source);
  }
}

void PointPair::MergeFrom(const PointPair& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:lidar_algorithm.common.proto.PointPair)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_left()) {
    mutable_left()->::lidar_algorithm::common::proto::Point2D::MergeFrom(from.left());
  }
  if (from.has_right()) {
    mutable_right()->::lidar_algorithm::common::proto::Point2D::MergeFrom(from.right());
  }
}

void PointPair::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:lidar_algorithm.common.proto.PointPair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PointPair::CopyFrom(const PointPair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lidar_algorithm.common.proto.PointPair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointPair::IsInitialized() const {
  return true;
}

void PointPair::Swap(PointPair* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PointPair::InternalSwap(PointPair* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(left_, other->left_);
  swap(right_, other->right_);
}

::google::protobuf::Metadata PointPair::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_geometry_2eproto);
  return ::file_level_metadata_geometry_2eproto[kIndexInFileMessages];
}


// ===================================================================

void PointTriple::InitAsDefaultInstance() {
  ::lidar_algorithm::common::proto::_PointTriple_default_instance_._instance.get_mutable()->left_ = const_cast< ::lidar_algorithm::common::proto::Point2D*>(
      ::lidar_algorithm::common::proto::Point2D::internal_default_instance());
  ::lidar_algorithm::common::proto::_PointTriple_default_instance_._instance.get_mutable()->middle_ = const_cast< ::lidar_algorithm::common::proto::Point2D*>(
      ::lidar_algorithm::common::proto::Point2D::internal_default_instance());
  ::lidar_algorithm::common::proto::_PointTriple_default_instance_._instance.get_mutable()->right_ = const_cast< ::lidar_algorithm::common::proto::Point2D*>(
      ::lidar_algorithm::common::proto::Point2D::internal_default_instance());
}
class PointTriple::HasBitSetters {
 public:
  static const ::lidar_algorithm::common::proto::Point2D& left(const PointTriple* msg);
  static const ::lidar_algorithm::common::proto::Point2D& middle(const PointTriple* msg);
  static const ::lidar_algorithm::common::proto::Point2D& right(const PointTriple* msg);
};

const ::lidar_algorithm::common::proto::Point2D&
PointTriple::HasBitSetters::left(const PointTriple* msg) {
  return *msg->left_;
}
const ::lidar_algorithm::common::proto::Point2D&
PointTriple::HasBitSetters::middle(const PointTriple* msg) {
  return *msg->middle_;
}
const ::lidar_algorithm::common::proto::Point2D&
PointTriple::HasBitSetters::right(const PointTriple* msg) {
  return *msg->right_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PointTriple::kLeftFieldNumber;
const int PointTriple::kMiddleFieldNumber;
const int PointTriple::kRightFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PointTriple::PointTriple()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:lidar_algorithm.common.proto.PointTriple)
}
PointTriple::PointTriple(const PointTriple& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_left()) {
    left_ = new ::lidar_algorithm::common::proto::Point2D(*from.left_);
  } else {
    left_ = nullptr;
  }
  if (from.has_middle()) {
    middle_ = new ::lidar_algorithm::common::proto::Point2D(*from.middle_);
  } else {
    middle_ = nullptr;
  }
  if (from.has_right()) {
    right_ = new ::lidar_algorithm::common::proto::Point2D(*from.right_);
  } else {
    right_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:lidar_algorithm.common.proto.PointTriple)
}

void PointTriple::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_PointTriple_geometry_2eproto.base);
  ::memset(&left_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&right_) -
      reinterpret_cast<char*>(&left_)) + sizeof(right_));
}

PointTriple::~PointTriple() {
  // @@protoc_insertion_point(destructor:lidar_algorithm.common.proto.PointTriple)
  SharedDtor();
}

void PointTriple::SharedDtor() {
  if (this != internal_default_instance()) delete left_;
  if (this != internal_default_instance()) delete middle_;
  if (this != internal_default_instance()) delete right_;
}

void PointTriple::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PointTriple& PointTriple::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_PointTriple_geometry_2eproto.base);
  return *internal_default_instance();
}


void PointTriple::Clear() {
// @@protoc_insertion_point(message_clear_start:lidar_algorithm.common.proto.PointTriple)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == nullptr && left_ != nullptr) {
    delete left_;
  }
  left_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && middle_ != nullptr) {
    delete middle_;
  }
  middle_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && right_ != nullptr) {
    delete right_;
  }
  right_ = nullptr;
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* PointTriple::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<PointTriple*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // .lidar_algorithm.common.proto.Point2D left = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::lidar_algorithm::common::proto::Point2D::_InternalParse;
        object = msg->mutable_left();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // .lidar_algorithm.common.proto.Point2D middle = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::lidar_algorithm::common::proto::Point2D::_InternalParse;
        object = msg->mutable_middle();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // .lidar_algorithm.common.proto.Point2D right = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::lidar_algorithm::common::proto::Point2D::_InternalParse;
        object = msg->mutable_right();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool PointTriple::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:lidar_algorithm.common.proto.PointTriple)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .lidar_algorithm.common.proto.Point2D left = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_left()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .lidar_algorithm.common.proto.Point2D middle = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_middle()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .lidar_algorithm.common.proto.Point2D right = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_right()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:lidar_algorithm.common.proto.PointTriple)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:lidar_algorithm.common.proto.PointTriple)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void PointTriple::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:lidar_algorithm.common.proto.PointTriple)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .lidar_algorithm.common.proto.Point2D left = 1;
  if (this->has_left()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::left(this), output);
  }

  // .lidar_algorithm.common.proto.Point2D middle = 2;
  if (this->has_middle()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::middle(this), output);
  }

  // .lidar_algorithm.common.proto.Point2D right = 3;
  if (this->has_right()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::right(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:lidar_algorithm.common.proto.PointTriple)
}

::google::protobuf::uint8* PointTriple::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:lidar_algorithm.common.proto.PointTriple)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .lidar_algorithm.common.proto.Point2D left = 1;
  if (this->has_left()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::left(this), target);
  }

  // .lidar_algorithm.common.proto.Point2D middle = 2;
  if (this->has_middle()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::middle(this), target);
  }

  // .lidar_algorithm.common.proto.Point2D right = 3;
  if (this->has_right()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::right(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lidar_algorithm.common.proto.PointTriple)
  return target;
}

size_t PointTriple::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lidar_algorithm.common.proto.PointTriple)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .lidar_algorithm.common.proto.Point2D left = 1;
  if (this->has_left()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *left_);
  }

  // .lidar_algorithm.common.proto.Point2D middle = 2;
  if (this->has_middle()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *middle_);
  }

  // .lidar_algorithm.common.proto.Point2D right = 3;
  if (this->has_right()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *right_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PointTriple::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:lidar_algorithm.common.proto.PointTriple)
  GOOGLE_DCHECK_NE(&from, this);
  const PointTriple* source =
      ::google::protobuf::DynamicCastToGenerated<PointTriple>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:lidar_algorithm.common.proto.PointTriple)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:lidar_algorithm.common.proto.PointTriple)
    MergeFrom(*source);
  }
}

void PointTriple::MergeFrom(const PointTriple& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:lidar_algorithm.common.proto.PointTriple)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_left()) {
    mutable_left()->::lidar_algorithm::common::proto::Point2D::MergeFrom(from.left());
  }
  if (from.has_middle()) {
    mutable_middle()->::lidar_algorithm::common::proto::Point2D::MergeFrom(from.middle());
  }
  if (from.has_right()) {
    mutable_right()->::lidar_algorithm::common::proto::Point2D::MergeFrom(from.right());
  }
}

void PointTriple::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:lidar_algorithm.common.proto.PointTriple)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PointTriple::CopyFrom(const PointTriple& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lidar_algorithm.common.proto.PointTriple)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointTriple::IsInitialized() const {
  return true;
}

void PointTriple::Swap(PointTriple* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PointTriple::InternalSwap(PointTriple* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(left_, other->left_);
  swap(middle_, other->middle_);
  swap(right_, other->right_);
}

::google::protobuf::Metadata PointTriple::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_geometry_2eproto);
  return ::file_level_metadata_geometry_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Box2D::InitAsDefaultInstance() {
}
class Box2D::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Box2D::kXFieldNumber;
const int Box2D::kYFieldNumber;
const int Box2D::kHeightFieldNumber;
const int Box2D::kWidthFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Box2D::Box2D()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:lidar_algorithm.common.proto.Box2D)
}
Box2D::Box2D(const Box2D& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&width_) -
    reinterpret_cast<char*>(&x_)) + sizeof(width_));
  // @@protoc_insertion_point(copy_constructor:lidar_algorithm.common.proto.Box2D)
}

void Box2D::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&width_) -
      reinterpret_cast<char*>(&x_)) + sizeof(width_));
}

Box2D::~Box2D() {
  // @@protoc_insertion_point(destructor:lidar_algorithm.common.proto.Box2D)
  SharedDtor();
}

void Box2D::SharedDtor() {
}

void Box2D::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Box2D& Box2D::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Box2D_geometry_2eproto.base);
  return *internal_default_instance();
}


void Box2D::Clear() {
// @@protoc_insertion_point(message_clear_start:lidar_algorithm.common.proto.Box2D)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&width_) -
      reinterpret_cast<char*>(&x_)) + sizeof(width_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Box2D::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Box2D*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // double x = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        msg->set_x(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // double y = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        msg->set_y(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // double height = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        msg->set_height(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // double width = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 33) goto handle_unusual;
        msg->set_width(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Box2D::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:lidar_algorithm.common.proto.Box2D)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // double x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double height = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &height_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double width = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (33 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &width_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:lidar_algorithm.common.proto.Box2D)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:lidar_algorithm.common.proto.Box2D)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Box2D::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:lidar_algorithm.common.proto.Box2D)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double x = 1;
  if (this->x() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // double y = 2;
  if (this->y() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // double height = 3;
  if (this->height() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->height(), output);
  }

  // double width = 4;
  if (this->width() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->width(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:lidar_algorithm.common.proto.Box2D)
}

::google::protobuf::uint8* Box2D::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:lidar_algorithm.common.proto.Box2D)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double x = 1;
  if (this->x() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // double y = 2;
  if (this->y() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // double height = 3;
  if (this->height() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->height(), target);
  }

  // double width = 4;
  if (this->width() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->width(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lidar_algorithm.common.proto.Box2D)
  return target;
}

size_t Box2D::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lidar_algorithm.common.proto.Box2D)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double x = 1;
  if (this->x() != 0) {
    total_size += 1 + 8;
  }

  // double y = 2;
  if (this->y() != 0) {
    total_size += 1 + 8;
  }

  // double height = 3;
  if (this->height() != 0) {
    total_size += 1 + 8;
  }

  // double width = 4;
  if (this->width() != 0) {
    total_size += 1 + 8;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Box2D::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:lidar_algorithm.common.proto.Box2D)
  GOOGLE_DCHECK_NE(&from, this);
  const Box2D* source =
      ::google::protobuf::DynamicCastToGenerated<Box2D>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:lidar_algorithm.common.proto.Box2D)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:lidar_algorithm.common.proto.Box2D)
    MergeFrom(*source);
  }
}

void Box2D::MergeFrom(const Box2D& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:lidar_algorithm.common.proto.Box2D)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.x() != 0) {
    set_x(from.x());
  }
  if (from.y() != 0) {
    set_y(from.y());
  }
  if (from.height() != 0) {
    set_height(from.height());
  }
  if (from.width() != 0) {
    set_width(from.width());
  }
}

void Box2D::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:lidar_algorithm.common.proto.Box2D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Box2D::CopyFrom(const Box2D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lidar_algorithm.common.proto.Box2D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Box2D::IsInitialized() const {
  return true;
}

void Box2D::Swap(Box2D* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Box2D::InternalSwap(Box2D* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(height_, other->height_);
  swap(width_, other->width_);
}

::google::protobuf::Metadata Box2D::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_geometry_2eproto);
  return ::file_level_metadata_geometry_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Box3D::InitAsDefaultInstance() {
}
class Box3D::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Box3D::kXFieldNumber;
const int Box3D::kYFieldNumber;
const int Box3D::kZFieldNumber;
const int Box3D::kLengthFieldNumber;
const int Box3D::kWidthFieldNumber;
const int Box3D::kHeightFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Box3D::Box3D()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:lidar_algorithm.common.proto.Box3D)
}
Box3D::Box3D(const Box3D& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&x_)) + sizeof(height_));
  // @@protoc_insertion_point(copy_constructor:lidar_algorithm.common.proto.Box3D)
}

void Box3D::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&height_) -
      reinterpret_cast<char*>(&x_)) + sizeof(height_));
}

Box3D::~Box3D() {
  // @@protoc_insertion_point(destructor:lidar_algorithm.common.proto.Box3D)
  SharedDtor();
}

void Box3D::SharedDtor() {
}

void Box3D::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Box3D& Box3D::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Box3D_geometry_2eproto.base);
  return *internal_default_instance();
}


void Box3D::Clear() {
// @@protoc_insertion_point(message_clear_start:lidar_algorithm.common.proto.Box3D)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&height_) -
      reinterpret_cast<char*>(&x_)) + sizeof(height_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Box3D::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Box3D*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // double x = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        msg->set_x(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // double y = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        msg->set_y(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // double z = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        msg->set_z(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // double length = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 33) goto handle_unusual;
        msg->set_length(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // double width = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 41) goto handle_unusual;
        msg->set_width(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // double height = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 49) goto handle_unusual;
        msg->set_height(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Box3D::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:lidar_algorithm.common.proto.Box3D)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // double x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double z = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double length = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (33 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &length_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double width = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (41 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &width_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double height = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (49 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &height_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:lidar_algorithm.common.proto.Box3D)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:lidar_algorithm.common.proto.Box3D)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Box3D::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:lidar_algorithm.common.proto.Box3D)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double x = 1;
  if (this->x() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // double y = 2;
  if (this->y() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // double z = 3;
  if (this->z() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }

  // double length = 4;
  if (this->length() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->length(), output);
  }

  // double width = 5;
  if (this->width() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->width(), output);
  }

  // double height = 6;
  if (this->height() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->height(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:lidar_algorithm.common.proto.Box3D)
}

::google::protobuf::uint8* Box3D::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:lidar_algorithm.common.proto.Box3D)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double x = 1;
  if (this->x() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // double y = 2;
  if (this->y() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // double z = 3;
  if (this->z() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->z(), target);
  }

  // double length = 4;
  if (this->length() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->length(), target);
  }

  // double width = 5;
  if (this->width() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->width(), target);
  }

  // double height = 6;
  if (this->height() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->height(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lidar_algorithm.common.proto.Box3D)
  return target;
}

size_t Box3D::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lidar_algorithm.common.proto.Box3D)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double x = 1;
  if (this->x() != 0) {
    total_size += 1 + 8;
  }

  // double y = 2;
  if (this->y() != 0) {
    total_size += 1 + 8;
  }

  // double z = 3;
  if (this->z() != 0) {
    total_size += 1 + 8;
  }

  // double length = 4;
  if (this->length() != 0) {
    total_size += 1 + 8;
  }

  // double width = 5;
  if (this->width() != 0) {
    total_size += 1 + 8;
  }

  // double height = 6;
  if (this->height() != 0) {
    total_size += 1 + 8;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Box3D::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:lidar_algorithm.common.proto.Box3D)
  GOOGLE_DCHECK_NE(&from, this);
  const Box3D* source =
      ::google::protobuf::DynamicCastToGenerated<Box3D>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:lidar_algorithm.common.proto.Box3D)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:lidar_algorithm.common.proto.Box3D)
    MergeFrom(*source);
  }
}

void Box3D::MergeFrom(const Box3D& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:lidar_algorithm.common.proto.Box3D)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.x() != 0) {
    set_x(from.x());
  }
  if (from.y() != 0) {
    set_y(from.y());
  }
  if (from.z() != 0) {
    set_z(from.z());
  }
  if (from.length() != 0) {
    set_length(from.length());
  }
  if (from.width() != 0) {
    set_width(from.width());
  }
  if (from.height() != 0) {
    set_height(from.height());
  }
}

void Box3D::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:lidar_algorithm.common.proto.Box3D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Box3D::CopyFrom(const Box3D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lidar_algorithm.common.proto.Box3D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Box3D::IsInitialized() const {
  return true;
}

void Box3D::Swap(Box3D* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Box3D::InternalSwap(Box3D* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(z_, other->z_);
  swap(length_, other->length_);
  swap(width_, other->width_);
  swap(height_, other->height_);
}

::google::protobuf::Metadata Box3D::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_geometry_2eproto);
  return ::file_level_metadata_geometry_2eproto[kIndexInFileMessages];
}


// ===================================================================

void PathLines::InitAsDefaultInstance() {
}
class PathLines::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PathLines::kLeftLine2FieldNumber;
const int PathLines::kLeftLine1FieldNumber;
const int PathLines::kLineFieldNumber;
const int PathLines::kRightLine1FieldNumber;
const int PathLines::kRightLine2FieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PathLines::PathLines()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:lidar_algorithm.common.proto.PathLines)
}
PathLines::PathLines(const PathLines& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      left_line_2_(from.left_line_2_),
      left_line_1_(from.left_line_1_),
      line_(from.line_),
      right_line_1_(from.right_line_1_),
      right_line_2_(from.right_line_2_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:lidar_algorithm.common.proto.PathLines)
}

void PathLines::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_PathLines_geometry_2eproto.base);
}

PathLines::~PathLines() {
  // @@protoc_insertion_point(destructor:lidar_algorithm.common.proto.PathLines)
  SharedDtor();
}

void PathLines::SharedDtor() {
}

void PathLines::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PathLines& PathLines::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_PathLines_geometry_2eproto.base);
  return *internal_default_instance();
}


void PathLines::Clear() {
// @@protoc_insertion_point(message_clear_start:lidar_algorithm.common.proto.PathLines)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  left_line_2_.Clear();
  left_line_1_.Clear();
  line_.Clear();
  right_line_1_.Clear();
  right_line_2_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* PathLines::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<PathLines*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated .lidar_algorithm.common.proto.Point2D left_line_2 = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::lidar_algorithm::common::proto::Point2D::_InternalParse;
          object = msg->add_left_line_2();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      // repeated .lidar_algorithm.common.proto.Point2D left_line_1 = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::lidar_algorithm::common::proto::Point2D::_InternalParse;
          object = msg->add_left_line_1();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      // repeated .lidar_algorithm.common.proto.Point2D line = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::lidar_algorithm::common::proto::Point2D::_InternalParse;
          object = msg->add_line();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 26 && (ptr += 1));
        break;
      }
      // repeated .lidar_algorithm.common.proto.Point2D right_line_1 = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::lidar_algorithm::common::proto::Point2D::_InternalParse;
          object = msg->add_right_line_1();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 34 && (ptr += 1));
        break;
      }
      // repeated .lidar_algorithm.common.proto.Point2D right_line_2 = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::lidar_algorithm::common::proto::Point2D::_InternalParse;
          object = msg->add_right_line_2();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 42 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool PathLines::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:lidar_algorithm.common.proto.PathLines)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .lidar_algorithm.common.proto.Point2D left_line_2 = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_left_line_2()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .lidar_algorithm.common.proto.Point2D left_line_1 = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_left_line_1()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .lidar_algorithm.common.proto.Point2D line = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_line()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .lidar_algorithm.common.proto.Point2D right_line_1 = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_right_line_1()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .lidar_algorithm.common.proto.Point2D right_line_2 = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_right_line_2()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:lidar_algorithm.common.proto.PathLines)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:lidar_algorithm.common.proto.PathLines)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void PathLines::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:lidar_algorithm.common.proto.PathLines)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .lidar_algorithm.common.proto.Point2D left_line_2 = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->left_line_2_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->left_line_2(static_cast<int>(i)),
      output);
  }

  // repeated .lidar_algorithm.common.proto.Point2D left_line_1 = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->left_line_1_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->left_line_1(static_cast<int>(i)),
      output);
  }

  // repeated .lidar_algorithm.common.proto.Point2D line = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->line_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3,
      this->line(static_cast<int>(i)),
      output);
  }

  // repeated .lidar_algorithm.common.proto.Point2D right_line_1 = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->right_line_1_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4,
      this->right_line_1(static_cast<int>(i)),
      output);
  }

  // repeated .lidar_algorithm.common.proto.Point2D right_line_2 = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->right_line_2_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5,
      this->right_line_2(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:lidar_algorithm.common.proto.PathLines)
}

::google::protobuf::uint8* PathLines::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:lidar_algorithm.common.proto.PathLines)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .lidar_algorithm.common.proto.Point2D left_line_2 = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->left_line_2_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->left_line_2(static_cast<int>(i)), target);
  }

  // repeated .lidar_algorithm.common.proto.Point2D left_line_1 = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->left_line_1_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->left_line_1(static_cast<int>(i)), target);
  }

  // repeated .lidar_algorithm.common.proto.Point2D line = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->line_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, this->line(static_cast<int>(i)), target);
  }

  // repeated .lidar_algorithm.common.proto.Point2D right_line_1 = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->right_line_1_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, this->right_line_1(static_cast<int>(i)), target);
  }

  // repeated .lidar_algorithm.common.proto.Point2D right_line_2 = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->right_line_2_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, this->right_line_2(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lidar_algorithm.common.proto.PathLines)
  return target;
}

size_t PathLines::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lidar_algorithm.common.proto.PathLines)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .lidar_algorithm.common.proto.Point2D left_line_2 = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->left_line_2_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->left_line_2(static_cast<int>(i)));
    }
  }

  // repeated .lidar_algorithm.common.proto.Point2D left_line_1 = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->left_line_1_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->left_line_1(static_cast<int>(i)));
    }
  }

  // repeated .lidar_algorithm.common.proto.Point2D line = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->line_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->line(static_cast<int>(i)));
    }
  }

  // repeated .lidar_algorithm.common.proto.Point2D right_line_1 = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->right_line_1_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->right_line_1(static_cast<int>(i)));
    }
  }

  // repeated .lidar_algorithm.common.proto.Point2D right_line_2 = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->right_line_2_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->right_line_2(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PathLines::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:lidar_algorithm.common.proto.PathLines)
  GOOGLE_DCHECK_NE(&from, this);
  const PathLines* source =
      ::google::protobuf::DynamicCastToGenerated<PathLines>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:lidar_algorithm.common.proto.PathLines)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:lidar_algorithm.common.proto.PathLines)
    MergeFrom(*source);
  }
}

void PathLines::MergeFrom(const PathLines& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:lidar_algorithm.common.proto.PathLines)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  left_line_2_.MergeFrom(from.left_line_2_);
  left_line_1_.MergeFrom(from.left_line_1_);
  line_.MergeFrom(from.line_);
  right_line_1_.MergeFrom(from.right_line_1_);
  right_line_2_.MergeFrom(from.right_line_2_);
}

void PathLines::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:lidar_algorithm.common.proto.PathLines)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PathLines::CopyFrom(const PathLines& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lidar_algorithm.common.proto.PathLines)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PathLines::IsInitialized() const {
  return true;
}

void PathLines::Swap(PathLines* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PathLines::InternalSwap(PathLines* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  CastToBase(&left_line_2_)->InternalSwap(CastToBase(&other->left_line_2_));
  CastToBase(&left_line_1_)->InternalSwap(CastToBase(&other->left_line_1_));
  CastToBase(&line_)->InternalSwap(CastToBase(&other->line_));
  CastToBase(&right_line_1_)->InternalSwap(CastToBase(&other->right_line_1_));
  CastToBase(&right_line_2_)->InternalSwap(CastToBase(&other->right_line_2_));
}

::google::protobuf::Metadata PathLines::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_geometry_2eproto);
  return ::file_level_metadata_geometry_2eproto[kIndexInFileMessages];
}


// ===================================================================

void ObsOccuPathPct::InitAsDefaultInstance() {
}
class ObsOccuPathPct::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ObsOccuPathPct::kLeftPctFieldNumber;
const int ObsOccuPathPct::kRightPctFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ObsOccuPathPct::ObsOccuPathPct()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:lidar_algorithm.common.proto.ObsOccuPathPct)
}
ObsOccuPathPct::ObsOccuPathPct(const ObsOccuPathPct& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&left_pct_, &from.left_pct_,
    static_cast<size_t>(reinterpret_cast<char*>(&right_pct_) -
    reinterpret_cast<char*>(&left_pct_)) + sizeof(right_pct_));
  // @@protoc_insertion_point(copy_constructor:lidar_algorithm.common.proto.ObsOccuPathPct)
}

void ObsOccuPathPct::SharedCtor() {
  ::memset(&left_pct_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&right_pct_) -
      reinterpret_cast<char*>(&left_pct_)) + sizeof(right_pct_));
}

ObsOccuPathPct::~ObsOccuPathPct() {
  // @@protoc_insertion_point(destructor:lidar_algorithm.common.proto.ObsOccuPathPct)
  SharedDtor();
}

void ObsOccuPathPct::SharedDtor() {
}

void ObsOccuPathPct::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ObsOccuPathPct& ObsOccuPathPct::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ObsOccuPathPct_geometry_2eproto.base);
  return *internal_default_instance();
}


void ObsOccuPathPct::Clear() {
// @@protoc_insertion_point(message_clear_start:lidar_algorithm.common.proto.ObsOccuPathPct)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&left_pct_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&right_pct_) -
      reinterpret_cast<char*>(&left_pct_)) + sizeof(right_pct_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ObsOccuPathPct::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ObsOccuPathPct*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // int32 left_pct = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_left_pct(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // int32 right_pct = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_right_pct(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ObsOccuPathPct::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:lidar_algorithm.common.proto.ObsOccuPathPct)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // int32 left_pct = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &left_pct_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 right_pct = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &right_pct_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:lidar_algorithm.common.proto.ObsOccuPathPct)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:lidar_algorithm.common.proto.ObsOccuPathPct)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ObsOccuPathPct::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:lidar_algorithm.common.proto.ObsOccuPathPct)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 left_pct = 1;
  if (this->left_pct() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->left_pct(), output);
  }

  // int32 right_pct = 2;
  if (this->right_pct() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->right_pct(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:lidar_algorithm.common.proto.ObsOccuPathPct)
}

::google::protobuf::uint8* ObsOccuPathPct::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:lidar_algorithm.common.proto.ObsOccuPathPct)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 left_pct = 1;
  if (this->left_pct() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->left_pct(), target);
  }

  // int32 right_pct = 2;
  if (this->right_pct() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->right_pct(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lidar_algorithm.common.proto.ObsOccuPathPct)
  return target;
}

size_t ObsOccuPathPct::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lidar_algorithm.common.proto.ObsOccuPathPct)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 left_pct = 1;
  if (this->left_pct() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->left_pct());
  }

  // int32 right_pct = 2;
  if (this->right_pct() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->right_pct());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ObsOccuPathPct::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:lidar_algorithm.common.proto.ObsOccuPathPct)
  GOOGLE_DCHECK_NE(&from, this);
  const ObsOccuPathPct* source =
      ::google::protobuf::DynamicCastToGenerated<ObsOccuPathPct>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:lidar_algorithm.common.proto.ObsOccuPathPct)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:lidar_algorithm.common.proto.ObsOccuPathPct)
    MergeFrom(*source);
  }
}

void ObsOccuPathPct::MergeFrom(const ObsOccuPathPct& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:lidar_algorithm.common.proto.ObsOccuPathPct)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.left_pct() != 0) {
    set_left_pct(from.left_pct());
  }
  if (from.right_pct() != 0) {
    set_right_pct(from.right_pct());
  }
}

void ObsOccuPathPct::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:lidar_algorithm.common.proto.ObsOccuPathPct)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ObsOccuPathPct::CopyFrom(const ObsOccuPathPct& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lidar_algorithm.common.proto.ObsOccuPathPct)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObsOccuPathPct::IsInitialized() const {
  return true;
}

void ObsOccuPathPct::Swap(ObsOccuPathPct* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ObsOccuPathPct::InternalSwap(ObsOccuPathPct* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(left_pct_, other->left_pct_);
  swap(right_pct_, other->right_pct_);
}

::google::protobuf::Metadata ObsOccuPathPct::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_geometry_2eproto);
  return ::file_level_metadata_geometry_2eproto[kIndexInFileMessages];
}


// ===================================================================

void PointXYZIL::InitAsDefaultInstance() {
}
class PointXYZIL::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PointXYZIL::kXFieldNumber;
const int PointXYZIL::kYFieldNumber;
const int PointXYZIL::kZFieldNumber;
const int PointXYZIL::kIntensityFieldNumber;
const int PointXYZIL::kLabelFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PointXYZIL::PointXYZIL()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:lidar_algorithm.common.proto.PointXYZIL)
}
PointXYZIL::PointXYZIL(const PointXYZIL& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&label_) -
    reinterpret_cast<char*>(&x_)) + sizeof(label_));
  // @@protoc_insertion_point(copy_constructor:lidar_algorithm.common.proto.PointXYZIL)
}

void PointXYZIL::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&label_) -
      reinterpret_cast<char*>(&x_)) + sizeof(label_));
}

PointXYZIL::~PointXYZIL() {
  // @@protoc_insertion_point(destructor:lidar_algorithm.common.proto.PointXYZIL)
  SharedDtor();
}

void PointXYZIL::SharedDtor() {
}

void PointXYZIL::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PointXYZIL& PointXYZIL::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_PointXYZIL_geometry_2eproto.base);
  return *internal_default_instance();
}


void PointXYZIL::Clear() {
// @@protoc_insertion_point(message_clear_start:lidar_algorithm.common.proto.PointXYZIL)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&label_) -
      reinterpret_cast<char*>(&x_)) + sizeof(label_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* PointXYZIL::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<PointXYZIL*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // double x = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        msg->set_x(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // double y = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        msg->set_y(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // double z = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        msg->set_z(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // double intensity = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 33) goto handle_unusual;
        msg->set_intensity(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // uint32 label = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        msg->set_label(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool PointXYZIL::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:lidar_algorithm.common.proto.PointXYZIL)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // double x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double z = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double intensity = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (33 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &intensity_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 label = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &label_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:lidar_algorithm.common.proto.PointXYZIL)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:lidar_algorithm.common.proto.PointXYZIL)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void PointXYZIL::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:lidar_algorithm.common.proto.PointXYZIL)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double x = 1;
  if (this->x() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // double y = 2;
  if (this->y() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // double z = 3;
  if (this->z() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }

  // double intensity = 4;
  if (this->intensity() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->intensity(), output);
  }

  // uint32 label = 5;
  if (this->label() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->label(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:lidar_algorithm.common.proto.PointXYZIL)
}

::google::protobuf::uint8* PointXYZIL::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:lidar_algorithm.common.proto.PointXYZIL)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double x = 1;
  if (this->x() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // double y = 2;
  if (this->y() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // double z = 3;
  if (this->z() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->z(), target);
  }

  // double intensity = 4;
  if (this->intensity() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->intensity(), target);
  }

  // uint32 label = 5;
  if (this->label() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->label(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lidar_algorithm.common.proto.PointXYZIL)
  return target;
}

size_t PointXYZIL::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lidar_algorithm.common.proto.PointXYZIL)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double x = 1;
  if (this->x() != 0) {
    total_size += 1 + 8;
  }

  // double y = 2;
  if (this->y() != 0) {
    total_size += 1 + 8;
  }

  // double z = 3;
  if (this->z() != 0) {
    total_size += 1 + 8;
  }

  // double intensity = 4;
  if (this->intensity() != 0) {
    total_size += 1 + 8;
  }

  // uint32 label = 5;
  if (this->label() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->label());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PointXYZIL::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:lidar_algorithm.common.proto.PointXYZIL)
  GOOGLE_DCHECK_NE(&from, this);
  const PointXYZIL* source =
      ::google::protobuf::DynamicCastToGenerated<PointXYZIL>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:lidar_algorithm.common.proto.PointXYZIL)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:lidar_algorithm.common.proto.PointXYZIL)
    MergeFrom(*source);
  }
}

void PointXYZIL::MergeFrom(const PointXYZIL& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:lidar_algorithm.common.proto.PointXYZIL)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.x() != 0) {
    set_x(from.x());
  }
  if (from.y() != 0) {
    set_y(from.y());
  }
  if (from.z() != 0) {
    set_z(from.z());
  }
  if (from.intensity() != 0) {
    set_intensity(from.intensity());
  }
  if (from.label() != 0) {
    set_label(from.label());
  }
}

void PointXYZIL::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:lidar_algorithm.common.proto.PointXYZIL)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PointXYZIL::CopyFrom(const PointXYZIL& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lidar_algorithm.common.proto.PointXYZIL)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointXYZIL::IsInitialized() const {
  return true;
}

void PointXYZIL::Swap(PointXYZIL* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PointXYZIL::InternalSwap(PointXYZIL* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(z_, other->z_);
  swap(intensity_, other->intensity_);
  swap(label_, other->label_);
}

::google::protobuf::Metadata PointXYZIL::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_geometry_2eproto);
  return ::file_level_metadata_geometry_2eproto[kIndexInFileMessages];
}


// ===================================================================

void PointCloud::InitAsDefaultInstance() {
}
class PointCloud::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PointCloud::kTimestampFieldNumber;
const int PointCloud::kPointsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PointCloud::PointCloud()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:lidar_algorithm.common.proto.PointCloud)
}
PointCloud::PointCloud(const PointCloud& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      points_(from.points_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  timestamp_ = from.timestamp_;
  // @@protoc_insertion_point(copy_constructor:lidar_algorithm.common.proto.PointCloud)
}

void PointCloud::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_PointCloud_geometry_2eproto.base);
  timestamp_ = PROTOBUF_LONGLONG(0);
}

PointCloud::~PointCloud() {
  // @@protoc_insertion_point(destructor:lidar_algorithm.common.proto.PointCloud)
  SharedDtor();
}

void PointCloud::SharedDtor() {
}

void PointCloud::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PointCloud& PointCloud::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_PointCloud_geometry_2eproto.base);
  return *internal_default_instance();
}


void PointCloud::Clear() {
// @@protoc_insertion_point(message_clear_start:lidar_algorithm.common.proto.PointCloud)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  points_.Clear();
  timestamp_ = PROTOBUF_LONGLONG(0);
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* PointCloud::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<PointCloud*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // int64 timestamp = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_timestamp(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // repeated .lidar_algorithm.common.proto.PointXYZIL points = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::lidar_algorithm::common::proto::PointXYZIL::_InternalParse;
          object = msg->add_points();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool PointCloud::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:lidar_algorithm.common.proto.PointCloud)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // int64 timestamp = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &timestamp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .lidar_algorithm.common.proto.PointXYZIL points = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_points()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:lidar_algorithm.common.proto.PointCloud)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:lidar_algorithm.common.proto.PointCloud)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void PointCloud::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:lidar_algorithm.common.proto.PointCloud)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 timestamp = 1;
  if (this->timestamp() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->timestamp(), output);
  }

  // repeated .lidar_algorithm.common.proto.PointXYZIL points = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->points_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->points(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:lidar_algorithm.common.proto.PointCloud)
}

::google::protobuf::uint8* PointCloud::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:lidar_algorithm.common.proto.PointCloud)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 timestamp = 1;
  if (this->timestamp() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->timestamp(), target);
  }

  // repeated .lidar_algorithm.common.proto.PointXYZIL points = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->points_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->points(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lidar_algorithm.common.proto.PointCloud)
  return target;
}

size_t PointCloud::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lidar_algorithm.common.proto.PointCloud)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .lidar_algorithm.common.proto.PointXYZIL points = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->points_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->points(static_cast<int>(i)));
    }
  }

  // int64 timestamp = 1;
  if (this->timestamp() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->timestamp());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PointCloud::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:lidar_algorithm.common.proto.PointCloud)
  GOOGLE_DCHECK_NE(&from, this);
  const PointCloud* source =
      ::google::protobuf::DynamicCastToGenerated<PointCloud>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:lidar_algorithm.common.proto.PointCloud)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:lidar_algorithm.common.proto.PointCloud)
    MergeFrom(*source);
  }
}

void PointCloud::MergeFrom(const PointCloud& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:lidar_algorithm.common.proto.PointCloud)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  points_.MergeFrom(from.points_);
  if (from.timestamp() != 0) {
    set_timestamp(from.timestamp());
  }
}

void PointCloud::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:lidar_algorithm.common.proto.PointCloud)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PointCloud::CopyFrom(const PointCloud& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lidar_algorithm.common.proto.PointCloud)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointCloud::IsInitialized() const {
  return true;
}

void PointCloud::Swap(PointCloud* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PointCloud::InternalSwap(PointCloud* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  CastToBase(&points_)->InternalSwap(CastToBase(&other->points_));
  swap(timestamp_, other->timestamp_);
}

::google::protobuf::Metadata PointCloud::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_geometry_2eproto);
  return ::file_level_metadata_geometry_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Quaternion::InitAsDefaultInstance() {
}
class Quaternion::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Quaternion::kWFieldNumber;
const int Quaternion::kXFieldNumber;
const int Quaternion::kYFieldNumber;
const int Quaternion::kZFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Quaternion::Quaternion()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:lidar_algorithm.common.proto.Quaternion)
}
Quaternion::Quaternion(const Quaternion& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&w_, &from.w_,
    static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&w_)) + sizeof(z_));
  // @@protoc_insertion_point(copy_constructor:lidar_algorithm.common.proto.Quaternion)
}

void Quaternion::SharedCtor() {
  ::memset(&w_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&w_)) + sizeof(z_));
}

Quaternion::~Quaternion() {
  // @@protoc_insertion_point(destructor:lidar_algorithm.common.proto.Quaternion)
  SharedDtor();
}

void Quaternion::SharedDtor() {
}

void Quaternion::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Quaternion& Quaternion::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Quaternion_geometry_2eproto.base);
  return *internal_default_instance();
}


void Quaternion::Clear() {
// @@protoc_insertion_point(message_clear_start:lidar_algorithm.common.proto.Quaternion)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&w_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&w_)) + sizeof(z_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Quaternion::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Quaternion*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // double w = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        msg->set_w(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // double x = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        msg->set_x(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // double y = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        msg->set_y(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      // double z = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 33) goto handle_unusual;
        msg->set_z(::google::protobuf::io::UnalignedLoad<double>(ptr));
        ptr += sizeof(double);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Quaternion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:lidar_algorithm.common.proto.Quaternion)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // double w = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &w_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double x = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double y = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double z = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (33 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:lidar_algorithm.common.proto.Quaternion)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:lidar_algorithm.common.proto.Quaternion)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Quaternion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:lidar_algorithm.common.proto.Quaternion)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double w = 1;
  if (this->w() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->w(), output);
  }

  // double x = 2;
  if (this->x() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->x(), output);
  }

  // double y = 3;
  if (this->y() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->y(), output);
  }

  // double z = 4;
  if (this->z() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->z(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:lidar_algorithm.common.proto.Quaternion)
}

::google::protobuf::uint8* Quaternion::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:lidar_algorithm.common.proto.Quaternion)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double w = 1;
  if (this->w() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->w(), target);
  }

  // double x = 2;
  if (this->x() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->x(), target);
  }

  // double y = 3;
  if (this->y() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->y(), target);
  }

  // double z = 4;
  if (this->z() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->z(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lidar_algorithm.common.proto.Quaternion)
  return target;
}

size_t Quaternion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lidar_algorithm.common.proto.Quaternion)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double w = 1;
  if (this->w() != 0) {
    total_size += 1 + 8;
  }

  // double x = 2;
  if (this->x() != 0) {
    total_size += 1 + 8;
  }

  // double y = 3;
  if (this->y() != 0) {
    total_size += 1 + 8;
  }

  // double z = 4;
  if (this->z() != 0) {
    total_size += 1 + 8;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Quaternion::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:lidar_algorithm.common.proto.Quaternion)
  GOOGLE_DCHECK_NE(&from, this);
  const Quaternion* source =
      ::google::protobuf::DynamicCastToGenerated<Quaternion>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:lidar_algorithm.common.proto.Quaternion)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:lidar_algorithm.common.proto.Quaternion)
    MergeFrom(*source);
  }
}

void Quaternion::MergeFrom(const Quaternion& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:lidar_algorithm.common.proto.Quaternion)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.w() != 0) {
    set_w(from.w());
  }
  if (from.x() != 0) {
    set_x(from.x());
  }
  if (from.y() != 0) {
    set_y(from.y());
  }
  if (from.z() != 0) {
    set_z(from.z());
  }
}

void Quaternion::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:lidar_algorithm.common.proto.Quaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Quaternion::CopyFrom(const Quaternion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lidar_algorithm.common.proto.Quaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Quaternion::IsInitialized() const {
  return true;
}

void Quaternion::Swap(Quaternion* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Quaternion::InternalSwap(Quaternion* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(w_, other->w_);
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(z_, other->z_);
}

::google::protobuf::Metadata Quaternion::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_geometry_2eproto);
  return ::file_level_metadata_geometry_2eproto[kIndexInFileMessages];
}


// ===================================================================

void AABB3D::InitAsDefaultInstance() {
  ::lidar_algorithm::common::proto::_AABB3D_default_instance_._instance.get_mutable()->min_point_ = const_cast< ::lidar_algorithm::common::proto::Point3D*>(
      ::lidar_algorithm::common::proto::Point3D::internal_default_instance());
  ::lidar_algorithm::common::proto::_AABB3D_default_instance_._instance.get_mutable()->max_point_ = const_cast< ::lidar_algorithm::common::proto::Point3D*>(
      ::lidar_algorithm::common::proto::Point3D::internal_default_instance());
}
class AABB3D::HasBitSetters {
 public:
  static const ::lidar_algorithm::common::proto::Point3D& min_point(const AABB3D* msg);
  static const ::lidar_algorithm::common::proto::Point3D& max_point(const AABB3D* msg);
};

const ::lidar_algorithm::common::proto::Point3D&
AABB3D::HasBitSetters::min_point(const AABB3D* msg) {
  return *msg->min_point_;
}
const ::lidar_algorithm::common::proto::Point3D&
AABB3D::HasBitSetters::max_point(const AABB3D* msg) {
  return *msg->max_point_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AABB3D::kMinPointFieldNumber;
const int AABB3D::kMaxPointFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AABB3D::AABB3D()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:lidar_algorithm.common.proto.AABB3D)
}
AABB3D::AABB3D(const AABB3D& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_min_point()) {
    min_point_ = new ::lidar_algorithm::common::proto::Point3D(*from.min_point_);
  } else {
    min_point_ = nullptr;
  }
  if (from.has_max_point()) {
    max_point_ = new ::lidar_algorithm::common::proto::Point3D(*from.max_point_);
  } else {
    max_point_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:lidar_algorithm.common.proto.AABB3D)
}

void AABB3D::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_AABB3D_geometry_2eproto.base);
  ::memset(&min_point_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_point_) -
      reinterpret_cast<char*>(&min_point_)) + sizeof(max_point_));
}

AABB3D::~AABB3D() {
  // @@protoc_insertion_point(destructor:lidar_algorithm.common.proto.AABB3D)
  SharedDtor();
}

void AABB3D::SharedDtor() {
  if (this != internal_default_instance()) delete min_point_;
  if (this != internal_default_instance()) delete max_point_;
}

void AABB3D::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AABB3D& AABB3D::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_AABB3D_geometry_2eproto.base);
  return *internal_default_instance();
}


void AABB3D::Clear() {
// @@protoc_insertion_point(message_clear_start:lidar_algorithm.common.proto.AABB3D)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == nullptr && min_point_ != nullptr) {
    delete min_point_;
  }
  min_point_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && max_point_ != nullptr) {
    delete max_point_;
  }
  max_point_ = nullptr;
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* AABB3D::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<AABB3D*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // .lidar_algorithm.common.proto.Point3D min_point = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::lidar_algorithm::common::proto::Point3D::_InternalParse;
        object = msg->mutable_min_point();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // .lidar_algorithm.common.proto.Point3D max_point = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::lidar_algorithm::common::proto::Point3D::_InternalParse;
        object = msg->mutable_max_point();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool AABB3D::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:lidar_algorithm.common.proto.AABB3D)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .lidar_algorithm.common.proto.Point3D min_point = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_min_point()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .lidar_algorithm.common.proto.Point3D max_point = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_max_point()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:lidar_algorithm.common.proto.AABB3D)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:lidar_algorithm.common.proto.AABB3D)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void AABB3D::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:lidar_algorithm.common.proto.AABB3D)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .lidar_algorithm.common.proto.Point3D min_point = 1;
  if (this->has_min_point()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::min_point(this), output);
  }

  // .lidar_algorithm.common.proto.Point3D max_point = 2;
  if (this->has_max_point()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::max_point(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:lidar_algorithm.common.proto.AABB3D)
}

::google::protobuf::uint8* AABB3D::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:lidar_algorithm.common.proto.AABB3D)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .lidar_algorithm.common.proto.Point3D min_point = 1;
  if (this->has_min_point()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::min_point(this), target);
  }

  // .lidar_algorithm.common.proto.Point3D max_point = 2;
  if (this->has_max_point()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::max_point(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lidar_algorithm.common.proto.AABB3D)
  return target;
}

size_t AABB3D::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lidar_algorithm.common.proto.AABB3D)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .lidar_algorithm.common.proto.Point3D min_point = 1;
  if (this->has_min_point()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *min_point_);
  }

  // .lidar_algorithm.common.proto.Point3D max_point = 2;
  if (this->has_max_point()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *max_point_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AABB3D::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:lidar_algorithm.common.proto.AABB3D)
  GOOGLE_DCHECK_NE(&from, this);
  const AABB3D* source =
      ::google::protobuf::DynamicCastToGenerated<AABB3D>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:lidar_algorithm.common.proto.AABB3D)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:lidar_algorithm.common.proto.AABB3D)
    MergeFrom(*source);
  }
}

void AABB3D::MergeFrom(const AABB3D& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:lidar_algorithm.common.proto.AABB3D)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_min_point()) {
    mutable_min_point()->::lidar_algorithm::common::proto::Point3D::MergeFrom(from.min_point());
  }
  if (from.has_max_point()) {
    mutable_max_point()->::lidar_algorithm::common::proto::Point3D::MergeFrom(from.max_point());
  }
}

void AABB3D::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:lidar_algorithm.common.proto.AABB3D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AABB3D::CopyFrom(const AABB3D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lidar_algorithm.common.proto.AABB3D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AABB3D::IsInitialized() const {
  return true;
}

void AABB3D::Swap(AABB3D* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AABB3D::InternalSwap(AABB3D* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(min_point_, other->min_point_);
  swap(max_point_, other->max_point_);
}

::google::protobuf::Metadata AABB3D::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_geometry_2eproto);
  return ::file_level_metadata_geometry_2eproto[kIndexInFileMessages];
}


// ===================================================================

void AABB3Ds::InitAsDefaultInstance() {
}
class AABB3Ds::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AABB3Ds::kAabb3DsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AABB3Ds::AABB3Ds()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:lidar_algorithm.common.proto.AABB3Ds)
}
AABB3Ds::AABB3Ds(const AABB3Ds& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      aabb3ds_(from.aabb3ds_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:lidar_algorithm.common.proto.AABB3Ds)
}

void AABB3Ds::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_AABB3Ds_geometry_2eproto.base);
}

AABB3Ds::~AABB3Ds() {
  // @@protoc_insertion_point(destructor:lidar_algorithm.common.proto.AABB3Ds)
  SharedDtor();
}

void AABB3Ds::SharedDtor() {
}

void AABB3Ds::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AABB3Ds& AABB3Ds::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_AABB3Ds_geometry_2eproto.base);
  return *internal_default_instance();
}


void AABB3Ds::Clear() {
// @@protoc_insertion_point(message_clear_start:lidar_algorithm.common.proto.AABB3Ds)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  aabb3ds_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* AABB3Ds::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<AABB3Ds*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated .lidar_algorithm.common.proto.AABB3D aabb3ds = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::lidar_algorithm::common::proto::AABB3D::_InternalParse;
          object = msg->add_aabb3ds();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool AABB3Ds::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:lidar_algorithm.common.proto.AABB3Ds)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .lidar_algorithm.common.proto.AABB3D aabb3ds = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_aabb3ds()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:lidar_algorithm.common.proto.AABB3Ds)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:lidar_algorithm.common.proto.AABB3Ds)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void AABB3Ds::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:lidar_algorithm.common.proto.AABB3Ds)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .lidar_algorithm.common.proto.AABB3D aabb3ds = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->aabb3ds_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->aabb3ds(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:lidar_algorithm.common.proto.AABB3Ds)
}

::google::protobuf::uint8* AABB3Ds::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:lidar_algorithm.common.proto.AABB3Ds)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .lidar_algorithm.common.proto.AABB3D aabb3ds = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->aabb3ds_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->aabb3ds(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lidar_algorithm.common.proto.AABB3Ds)
  return target;
}

size_t AABB3Ds::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lidar_algorithm.common.proto.AABB3Ds)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .lidar_algorithm.common.proto.AABB3D aabb3ds = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->aabb3ds_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->aabb3ds(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AABB3Ds::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:lidar_algorithm.common.proto.AABB3Ds)
  GOOGLE_DCHECK_NE(&from, this);
  const AABB3Ds* source =
      ::google::protobuf::DynamicCastToGenerated<AABB3Ds>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:lidar_algorithm.common.proto.AABB3Ds)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:lidar_algorithm.common.proto.AABB3Ds)
    MergeFrom(*source);
  }
}

void AABB3Ds::MergeFrom(const AABB3Ds& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:lidar_algorithm.common.proto.AABB3Ds)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  aabb3ds_.MergeFrom(from.aabb3ds_);
}

void AABB3Ds::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:lidar_algorithm.common.proto.AABB3Ds)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AABB3Ds::CopyFrom(const AABB3Ds& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lidar_algorithm.common.proto.AABB3Ds)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AABB3Ds::IsInitialized() const {
  return true;
}

void AABB3Ds::Swap(AABB3Ds* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AABB3Ds::InternalSwap(AABB3Ds* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  CastToBase(&aabb3ds_)->InternalSwap(CastToBase(&other->aabb3ds_));
}

::google::protobuf::Metadata AABB3Ds::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_geometry_2eproto);
  return ::file_level_metadata_geometry_2eproto[kIndexInFileMessages];
}


// ===================================================================

void OBB3D::InitAsDefaultInstance() {
  ::lidar_algorithm::common::proto::_OBB3D_default_instance_._instance.get_mutable()->min_point_ = const_cast< ::lidar_algorithm::common::proto::Point3D*>(
      ::lidar_algorithm::common::proto::Point3D::internal_default_instance());
  ::lidar_algorithm::common::proto::_OBB3D_default_instance_._instance.get_mutable()->max_point_ = const_cast< ::lidar_algorithm::common::proto::Point3D*>(
      ::lidar_algorithm::common::proto::Point3D::internal_default_instance());
  ::lidar_algorithm::common::proto::_OBB3D_default_instance_._instance.get_mutable()->position_ = const_cast< ::lidar_algorithm::common::proto::Point3D*>(
      ::lidar_algorithm::common::proto::Point3D::internal_default_instance());
  ::lidar_algorithm::common::proto::_OBB3D_default_instance_._instance.get_mutable()->quat_ = const_cast< ::lidar_algorithm::common::proto::Quaternion*>(
      ::lidar_algorithm::common::proto::Quaternion::internal_default_instance());
}
class OBB3D::HasBitSetters {
 public:
  static const ::lidar_algorithm::common::proto::Point3D& min_point(const OBB3D* msg);
  static const ::lidar_algorithm::common::proto::Point3D& max_point(const OBB3D* msg);
  static const ::lidar_algorithm::common::proto::Point3D& position(const OBB3D* msg);
  static const ::lidar_algorithm::common::proto::Quaternion& quat(const OBB3D* msg);
};

const ::lidar_algorithm::common::proto::Point3D&
OBB3D::HasBitSetters::min_point(const OBB3D* msg) {
  return *msg->min_point_;
}
const ::lidar_algorithm::common::proto::Point3D&
OBB3D::HasBitSetters::max_point(const OBB3D* msg) {
  return *msg->max_point_;
}
const ::lidar_algorithm::common::proto::Point3D&
OBB3D::HasBitSetters::position(const OBB3D* msg) {
  return *msg->position_;
}
const ::lidar_algorithm::common::proto::Quaternion&
OBB3D::HasBitSetters::quat(const OBB3D* msg) {
  return *msg->quat_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int OBB3D::kMinPointFieldNumber;
const int OBB3D::kMaxPointFieldNumber;
const int OBB3D::kPositionFieldNumber;
const int OBB3D::kQuatFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

OBB3D::OBB3D()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:lidar_algorithm.common.proto.OBB3D)
}
OBB3D::OBB3D(const OBB3D& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_min_point()) {
    min_point_ = new ::lidar_algorithm::common::proto::Point3D(*from.min_point_);
  } else {
    min_point_ = nullptr;
  }
  if (from.has_max_point()) {
    max_point_ = new ::lidar_algorithm::common::proto::Point3D(*from.max_point_);
  } else {
    max_point_ = nullptr;
  }
  if (from.has_position()) {
    position_ = new ::lidar_algorithm::common::proto::Point3D(*from.position_);
  } else {
    position_ = nullptr;
  }
  if (from.has_quat()) {
    quat_ = new ::lidar_algorithm::common::proto::Quaternion(*from.quat_);
  } else {
    quat_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:lidar_algorithm.common.proto.OBB3D)
}

void OBB3D::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_OBB3D_geometry_2eproto.base);
  ::memset(&min_point_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&quat_) -
      reinterpret_cast<char*>(&min_point_)) + sizeof(quat_));
}

OBB3D::~OBB3D() {
  // @@protoc_insertion_point(destructor:lidar_algorithm.common.proto.OBB3D)
  SharedDtor();
}

void OBB3D::SharedDtor() {
  if (this != internal_default_instance()) delete min_point_;
  if (this != internal_default_instance()) delete max_point_;
  if (this != internal_default_instance()) delete position_;
  if (this != internal_default_instance()) delete quat_;
}

void OBB3D::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const OBB3D& OBB3D::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_OBB3D_geometry_2eproto.base);
  return *internal_default_instance();
}


void OBB3D::Clear() {
// @@protoc_insertion_point(message_clear_start:lidar_algorithm.common.proto.OBB3D)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == nullptr && min_point_ != nullptr) {
    delete min_point_;
  }
  min_point_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && max_point_ != nullptr) {
    delete max_point_;
  }
  max_point_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && quat_ != nullptr) {
    delete quat_;
  }
  quat_ = nullptr;
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* OBB3D::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<OBB3D*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // .lidar_algorithm.common.proto.Point3D min_point = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::lidar_algorithm::common::proto::Point3D::_InternalParse;
        object = msg->mutable_min_point();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // .lidar_algorithm.common.proto.Point3D max_point = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::lidar_algorithm::common::proto::Point3D::_InternalParse;
        object = msg->mutable_max_point();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // .lidar_algorithm.common.proto.Point3D position = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::lidar_algorithm::common::proto::Point3D::_InternalParse;
        object = msg->mutable_position();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // .lidar_algorithm.common.proto.Quaternion quat = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::lidar_algorithm::common::proto::Quaternion::_InternalParse;
        object = msg->mutable_quat();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool OBB3D::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:lidar_algorithm.common.proto.OBB3D)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .lidar_algorithm.common.proto.Point3D min_point = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_min_point()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .lidar_algorithm.common.proto.Point3D max_point = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_max_point()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .lidar_algorithm.common.proto.Point3D position = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .lidar_algorithm.common.proto.Quaternion quat = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_quat()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:lidar_algorithm.common.proto.OBB3D)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:lidar_algorithm.common.proto.OBB3D)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void OBB3D::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:lidar_algorithm.common.proto.OBB3D)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .lidar_algorithm.common.proto.Point3D min_point = 1;
  if (this->has_min_point()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::min_point(this), output);
  }

  // .lidar_algorithm.common.proto.Point3D max_point = 2;
  if (this->has_max_point()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::max_point(this), output);
  }

  // .lidar_algorithm.common.proto.Point3D position = 3;
  if (this->has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::position(this), output);
  }

  // .lidar_algorithm.common.proto.Quaternion quat = 4;
  if (this->has_quat()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, HasBitSetters::quat(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:lidar_algorithm.common.proto.OBB3D)
}

::google::protobuf::uint8* OBB3D::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:lidar_algorithm.common.proto.OBB3D)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .lidar_algorithm.common.proto.Point3D min_point = 1;
  if (this->has_min_point()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::min_point(this), target);
  }

  // .lidar_algorithm.common.proto.Point3D max_point = 2;
  if (this->has_max_point()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::max_point(this), target);
  }

  // .lidar_algorithm.common.proto.Point3D position = 3;
  if (this->has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::position(this), target);
  }

  // .lidar_algorithm.common.proto.Quaternion quat = 4;
  if (this->has_quat()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, HasBitSetters::quat(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lidar_algorithm.common.proto.OBB3D)
  return target;
}

size_t OBB3D::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lidar_algorithm.common.proto.OBB3D)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .lidar_algorithm.common.proto.Point3D min_point = 1;
  if (this->has_min_point()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *min_point_);
  }

  // .lidar_algorithm.common.proto.Point3D max_point = 2;
  if (this->has_max_point()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *max_point_);
  }

  // .lidar_algorithm.common.proto.Point3D position = 3;
  if (this->has_position()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *position_);
  }

  // .lidar_algorithm.common.proto.Quaternion quat = 4;
  if (this->has_quat()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *quat_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OBB3D::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:lidar_algorithm.common.proto.OBB3D)
  GOOGLE_DCHECK_NE(&from, this);
  const OBB3D* source =
      ::google::protobuf::DynamicCastToGenerated<OBB3D>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:lidar_algorithm.common.proto.OBB3D)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:lidar_algorithm.common.proto.OBB3D)
    MergeFrom(*source);
  }
}

void OBB3D::MergeFrom(const OBB3D& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:lidar_algorithm.common.proto.OBB3D)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_min_point()) {
    mutable_min_point()->::lidar_algorithm::common::proto::Point3D::MergeFrom(from.min_point());
  }
  if (from.has_max_point()) {
    mutable_max_point()->::lidar_algorithm::common::proto::Point3D::MergeFrom(from.max_point());
  }
  if (from.has_position()) {
    mutable_position()->::lidar_algorithm::common::proto::Point3D::MergeFrom(from.position());
  }
  if (from.has_quat()) {
    mutable_quat()->::lidar_algorithm::common::proto::Quaternion::MergeFrom(from.quat());
  }
}

void OBB3D::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:lidar_algorithm.common.proto.OBB3D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OBB3D::CopyFrom(const OBB3D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lidar_algorithm.common.proto.OBB3D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OBB3D::IsInitialized() const {
  return true;
}

void OBB3D::Swap(OBB3D* other) {
  if (other == this) return;
  InternalSwap(other);
}
void OBB3D::InternalSwap(OBB3D* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(min_point_, other->min_point_);
  swap(max_point_, other->max_point_);
  swap(position_, other->position_);
  swap(quat_, other->quat_);
}

::google::protobuf::Metadata OBB3D::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_geometry_2eproto);
  return ::file_level_metadata_geometry_2eproto[kIndexInFileMessages];
}


// ===================================================================

void OBB3Ds::InitAsDefaultInstance() {
}
class OBB3Ds::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int OBB3Ds::kObb3DsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

OBB3Ds::OBB3Ds()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:lidar_algorithm.common.proto.OBB3Ds)
}
OBB3Ds::OBB3Ds(const OBB3Ds& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      obb3ds_(from.obb3ds_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:lidar_algorithm.common.proto.OBB3Ds)
}

void OBB3Ds::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_OBB3Ds_geometry_2eproto.base);
}

OBB3Ds::~OBB3Ds() {
  // @@protoc_insertion_point(destructor:lidar_algorithm.common.proto.OBB3Ds)
  SharedDtor();
}

void OBB3Ds::SharedDtor() {
}

void OBB3Ds::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const OBB3Ds& OBB3Ds::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_OBB3Ds_geometry_2eproto.base);
  return *internal_default_instance();
}


void OBB3Ds::Clear() {
// @@protoc_insertion_point(message_clear_start:lidar_algorithm.common.proto.OBB3Ds)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  obb3ds_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* OBB3Ds::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<OBB3Ds*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated .lidar_algorithm.common.proto.OBB3D obb3ds = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::lidar_algorithm::common::proto::OBB3D::_InternalParse;
          object = msg->add_obb3ds();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool OBB3Ds::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:lidar_algorithm.common.proto.OBB3Ds)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .lidar_algorithm.common.proto.OBB3D obb3ds = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_obb3ds()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:lidar_algorithm.common.proto.OBB3Ds)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:lidar_algorithm.common.proto.OBB3Ds)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void OBB3Ds::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:lidar_algorithm.common.proto.OBB3Ds)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .lidar_algorithm.common.proto.OBB3D obb3ds = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->obb3ds_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->obb3ds(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:lidar_algorithm.common.proto.OBB3Ds)
}

::google::protobuf::uint8* OBB3Ds::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:lidar_algorithm.common.proto.OBB3Ds)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .lidar_algorithm.common.proto.OBB3D obb3ds = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->obb3ds_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->obb3ds(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lidar_algorithm.common.proto.OBB3Ds)
  return target;
}

size_t OBB3Ds::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lidar_algorithm.common.proto.OBB3Ds)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .lidar_algorithm.common.proto.OBB3D obb3ds = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->obb3ds_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->obb3ds(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OBB3Ds::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:lidar_algorithm.common.proto.OBB3Ds)
  GOOGLE_DCHECK_NE(&from, this);
  const OBB3Ds* source =
      ::google::protobuf::DynamicCastToGenerated<OBB3Ds>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:lidar_algorithm.common.proto.OBB3Ds)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:lidar_algorithm.common.proto.OBB3Ds)
    MergeFrom(*source);
  }
}

void OBB3Ds::MergeFrom(const OBB3Ds& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:lidar_algorithm.common.proto.OBB3Ds)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  obb3ds_.MergeFrom(from.obb3ds_);
}

void OBB3Ds::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:lidar_algorithm.common.proto.OBB3Ds)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OBB3Ds::CopyFrom(const OBB3Ds& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lidar_algorithm.common.proto.OBB3Ds)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OBB3Ds::IsInitialized() const {
  return true;
}

void OBB3Ds::Swap(OBB3Ds* other) {
  if (other == this) return;
  InternalSwap(other);
}
void OBB3Ds::InternalSwap(OBB3Ds* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  CastToBase(&obb3ds_)->InternalSwap(CastToBase(&other->obb3ds_));
}

::google::protobuf::Metadata OBB3Ds::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_geometry_2eproto);
  return ::file_level_metadata_geometry_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Cluster::InitAsDefaultInstance() {
}
class Cluster::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Cluster::kPointsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Cluster::Cluster()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:lidar_algorithm.common.proto.Cluster)
}
Cluster::Cluster(const Cluster& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      points_(from.points_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:lidar_algorithm.common.proto.Cluster)
}

void Cluster::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Cluster_geometry_2eproto.base);
}

Cluster::~Cluster() {
  // @@protoc_insertion_point(destructor:lidar_algorithm.common.proto.Cluster)
  SharedDtor();
}

void Cluster::SharedDtor() {
}

void Cluster::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Cluster& Cluster::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Cluster_geometry_2eproto.base);
  return *internal_default_instance();
}


void Cluster::Clear() {
// @@protoc_insertion_point(message_clear_start:lidar_algorithm.common.proto.Cluster)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  points_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Cluster::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Cluster*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated .lidar_algorithm.common.proto.Point3D points = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::lidar_algorithm::common::proto::Point3D::_InternalParse;
          object = msg->add_points();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Cluster::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:lidar_algorithm.common.proto.Cluster)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .lidar_algorithm.common.proto.Point3D points = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_points()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:lidar_algorithm.common.proto.Cluster)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:lidar_algorithm.common.proto.Cluster)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Cluster::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:lidar_algorithm.common.proto.Cluster)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .lidar_algorithm.common.proto.Point3D points = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->points_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->points(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:lidar_algorithm.common.proto.Cluster)
}

::google::protobuf::uint8* Cluster::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:lidar_algorithm.common.proto.Cluster)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .lidar_algorithm.common.proto.Point3D points = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->points_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->points(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lidar_algorithm.common.proto.Cluster)
  return target;
}

size_t Cluster::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lidar_algorithm.common.proto.Cluster)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .lidar_algorithm.common.proto.Point3D points = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->points_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->points(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Cluster::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:lidar_algorithm.common.proto.Cluster)
  GOOGLE_DCHECK_NE(&from, this);
  const Cluster* source =
      ::google::protobuf::DynamicCastToGenerated<Cluster>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:lidar_algorithm.common.proto.Cluster)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:lidar_algorithm.common.proto.Cluster)
    MergeFrom(*source);
  }
}

void Cluster::MergeFrom(const Cluster& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:lidar_algorithm.common.proto.Cluster)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  points_.MergeFrom(from.points_);
}

void Cluster::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:lidar_algorithm.common.proto.Cluster)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Cluster::CopyFrom(const Cluster& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lidar_algorithm.common.proto.Cluster)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Cluster::IsInitialized() const {
  return true;
}

void Cluster::Swap(Cluster* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Cluster::InternalSwap(Cluster* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  CastToBase(&points_)->InternalSwap(CastToBase(&other->points_));
}

::google::protobuf::Metadata Cluster::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_geometry_2eproto);
  return ::file_level_metadata_geometry_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Clusters::InitAsDefaultInstance() {
}
class Clusters::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Clusters::kClustersFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Clusters::Clusters()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:lidar_algorithm.common.proto.Clusters)
}
Clusters::Clusters(const Clusters& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      clusters_(from.clusters_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:lidar_algorithm.common.proto.Clusters)
}

void Clusters::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Clusters_geometry_2eproto.base);
}

Clusters::~Clusters() {
  // @@protoc_insertion_point(destructor:lidar_algorithm.common.proto.Clusters)
  SharedDtor();
}

void Clusters::SharedDtor() {
}

void Clusters::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Clusters& Clusters::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Clusters_geometry_2eproto.base);
  return *internal_default_instance();
}


void Clusters::Clear() {
// @@protoc_insertion_point(message_clear_start:lidar_algorithm.common.proto.Clusters)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clusters_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Clusters::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Clusters*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated .lidar_algorithm.common.proto.Cluster clusters = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::lidar_algorithm::common::proto::Cluster::_InternalParse;
          object = msg->add_clusters();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Clusters::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:lidar_algorithm.common.proto.Clusters)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .lidar_algorithm.common.proto.Cluster clusters = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_clusters()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:lidar_algorithm.common.proto.Clusters)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:lidar_algorithm.common.proto.Clusters)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Clusters::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:lidar_algorithm.common.proto.Clusters)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .lidar_algorithm.common.proto.Cluster clusters = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->clusters_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->clusters(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:lidar_algorithm.common.proto.Clusters)
}

::google::protobuf::uint8* Clusters::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:lidar_algorithm.common.proto.Clusters)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .lidar_algorithm.common.proto.Cluster clusters = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->clusters_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->clusters(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lidar_algorithm.common.proto.Clusters)
  return target;
}

size_t Clusters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lidar_algorithm.common.proto.Clusters)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .lidar_algorithm.common.proto.Cluster clusters = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->clusters_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->clusters(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Clusters::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:lidar_algorithm.common.proto.Clusters)
  GOOGLE_DCHECK_NE(&from, this);
  const Clusters* source =
      ::google::protobuf::DynamicCastToGenerated<Clusters>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:lidar_algorithm.common.proto.Clusters)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:lidar_algorithm.common.proto.Clusters)
    MergeFrom(*source);
  }
}

void Clusters::MergeFrom(const Clusters& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:lidar_algorithm.common.proto.Clusters)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  clusters_.MergeFrom(from.clusters_);
}

void Clusters::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:lidar_algorithm.common.proto.Clusters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Clusters::CopyFrom(const Clusters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lidar_algorithm.common.proto.Clusters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Clusters::IsInitialized() const {
  return true;
}

void Clusters::Swap(Clusters* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Clusters::InternalSwap(Clusters* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  CastToBase(&clusters_)->InternalSwap(CastToBase(&other->clusters_));
}

::google::protobuf::Metadata Clusters::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_geometry_2eproto);
  return ::file_level_metadata_geometry_2eproto[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace common
}  // namespace lidar_algorithm
namespace google {
namespace protobuf {
template<> PROTOBUF_NOINLINE ::lidar_algorithm::common::proto::Point2D* Arena::CreateMaybeMessage< ::lidar_algorithm::common::proto::Point2D >(Arena* arena) {
  return Arena::CreateInternal< ::lidar_algorithm::common::proto::Point2D >(arena);
}
template<> PROTOBUF_NOINLINE ::lidar_algorithm::common::proto::Point3D* Arena::CreateMaybeMessage< ::lidar_algorithm::common::proto::Point3D >(Arena* arena) {
  return Arena::CreateInternal< ::lidar_algorithm::common::proto::Point3D >(arena);
}
template<> PROTOBUF_NOINLINE ::lidar_algorithm::common::proto::Polygon* Arena::CreateMaybeMessage< ::lidar_algorithm::common::proto::Polygon >(Arena* arena) {
  return Arena::CreateInternal< ::lidar_algorithm::common::proto::Polygon >(arena);
}
template<> PROTOBUF_NOINLINE ::lidar_algorithm::common::proto::PointPair* Arena::CreateMaybeMessage< ::lidar_algorithm::common::proto::PointPair >(Arena* arena) {
  return Arena::CreateInternal< ::lidar_algorithm::common::proto::PointPair >(arena);
}
template<> PROTOBUF_NOINLINE ::lidar_algorithm::common::proto::PointTriple* Arena::CreateMaybeMessage< ::lidar_algorithm::common::proto::PointTriple >(Arena* arena) {
  return Arena::CreateInternal< ::lidar_algorithm::common::proto::PointTriple >(arena);
}
template<> PROTOBUF_NOINLINE ::lidar_algorithm::common::proto::Box2D* Arena::CreateMaybeMessage< ::lidar_algorithm::common::proto::Box2D >(Arena* arena) {
  return Arena::CreateInternal< ::lidar_algorithm::common::proto::Box2D >(arena);
}
template<> PROTOBUF_NOINLINE ::lidar_algorithm::common::proto::Box3D* Arena::CreateMaybeMessage< ::lidar_algorithm::common::proto::Box3D >(Arena* arena) {
  return Arena::CreateInternal< ::lidar_algorithm::common::proto::Box3D >(arena);
}
template<> PROTOBUF_NOINLINE ::lidar_algorithm::common::proto::PathLines* Arena::CreateMaybeMessage< ::lidar_algorithm::common::proto::PathLines >(Arena* arena) {
  return Arena::CreateInternal< ::lidar_algorithm::common::proto::PathLines >(arena);
}
template<> PROTOBUF_NOINLINE ::lidar_algorithm::common::proto::ObsOccuPathPct* Arena::CreateMaybeMessage< ::lidar_algorithm::common::proto::ObsOccuPathPct >(Arena* arena) {
  return Arena::CreateInternal< ::lidar_algorithm::common::proto::ObsOccuPathPct >(arena);
}
template<> PROTOBUF_NOINLINE ::lidar_algorithm::common::proto::PointXYZIL* Arena::CreateMaybeMessage< ::lidar_algorithm::common::proto::PointXYZIL >(Arena* arena) {
  return Arena::CreateInternal< ::lidar_algorithm::common::proto::PointXYZIL >(arena);
}
template<> PROTOBUF_NOINLINE ::lidar_algorithm::common::proto::PointCloud* Arena::CreateMaybeMessage< ::lidar_algorithm::common::proto::PointCloud >(Arena* arena) {
  return Arena::CreateInternal< ::lidar_algorithm::common::proto::PointCloud >(arena);
}
template<> PROTOBUF_NOINLINE ::lidar_algorithm::common::proto::Quaternion* Arena::CreateMaybeMessage< ::lidar_algorithm::common::proto::Quaternion >(Arena* arena) {
  return Arena::CreateInternal< ::lidar_algorithm::common::proto::Quaternion >(arena);
}
template<> PROTOBUF_NOINLINE ::lidar_algorithm::common::proto::AABB3D* Arena::CreateMaybeMessage< ::lidar_algorithm::common::proto::AABB3D >(Arena* arena) {
  return Arena::CreateInternal< ::lidar_algorithm::common::proto::AABB3D >(arena);
}
template<> PROTOBUF_NOINLINE ::lidar_algorithm::common::proto::AABB3Ds* Arena::CreateMaybeMessage< ::lidar_algorithm::common::proto::AABB3Ds >(Arena* arena) {
  return Arena::CreateInternal< ::lidar_algorithm::common::proto::AABB3Ds >(arena);
}
template<> PROTOBUF_NOINLINE ::lidar_algorithm::common::proto::OBB3D* Arena::CreateMaybeMessage< ::lidar_algorithm::common::proto::OBB3D >(Arena* arena) {
  return Arena::CreateInternal< ::lidar_algorithm::common::proto::OBB3D >(arena);
}
template<> PROTOBUF_NOINLINE ::lidar_algorithm::common::proto::OBB3Ds* Arena::CreateMaybeMessage< ::lidar_algorithm::common::proto::OBB3Ds >(Arena* arena) {
  return Arena::CreateInternal< ::lidar_algorithm::common::proto::OBB3Ds >(arena);
}
template<> PROTOBUF_NOINLINE ::lidar_algorithm::common::proto::Cluster* Arena::CreateMaybeMessage< ::lidar_algorithm::common::proto::Cluster >(Arena* arena) {
  return Arena::CreateInternal< ::lidar_algorithm::common::proto::Cluster >(arena);
}
template<> PROTOBUF_NOINLINE ::lidar_algorithm::common::proto::Clusters* Arena::CreateMaybeMessage< ::lidar_algorithm::common::proto::Clusters >(Arena* arena) {
  return Arena::CreateInternal< ::lidar_algorithm::common::proto::Clusters >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
